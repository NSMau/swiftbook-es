---
title: Un Recorrido Por Swift
---

import Callout from '@components/Callout'
import Hero from '@components/Hero'

<Hero>
  # Un Recorrido Por Swift

  Explora las caracter√≠sticas y la sintaxis de Swift.
</Hero>

Es costumbre que el primer programa que se crea al aprender un nuevo lenguaje de programaci√≥n es aquel que imprime la frase _¬°Hola, mundo!_ en la pantalla. En Swift, esto se puede conseguir mediante una sola l√≠nea de c√≥digo:

```swift showLineNumbers
print("¬°Hola, mundo!")
// Imprime "¬°Hola, mundo!"
```

Si has desarollado anteriormente en C u Objective-C, esta sintaxis te resultar√° familiar; en Swift, esta l√≠nea de c√≥digo representa un programa completo. No hace falta importar una biblioteca aparte para contar con funciones como entrada/salida o manejo de cadenas de texto. Todo c√≥digo escrito en el √°mbito (_scope_) global se utiliza como punto de entrada para el programa, por lo que no necesitamos una funci√≥n `main()`. Tampoco hace falta escribir punto y coma al final de cada declaraci√≥n.

Esta gu√≠a te proporciona suficiente informaci√≥n para comenzar a desarrollar c√≥digo en Swift al ense√±arte c√≥mo realizar una variedad de tareas de programaci√≥n. No te preocupes si hay algo que no entiendes: todo lo presentado en esta gu√≠a se explica en detalle en el resto de este libro.

## Valores sencillos

Usa `let` para crear una constante y `var` para crear una variable. No es necesario conocer el valor de una constante a la hora de compilar, pero tal valor debe asignarse exactamente una √∫nica vez. Esto significa que puedes usar constantes para nombrar un valor que solo se define una vez, pero que se usa en muchas partes.

```swift showLineNumbers
var miVariable = 42
miVariable = 50
let miConstante = 42
```

Una constante o variable debe ser del mismo tipo que el valor que se le quiera asignar. Sin embargo, no siempre tienes que escribir el tipo expl√≠citamente. El hecho de proporcionar un valor a una variable o constante durante su creaci√≥n, le permite al compilador inferir el tipo de dicha variable o constante. En el ejemplo anterior, el compilador infiere que `miVariable` es un entero porque su valor inicial es un entero.

Si el valor inicial no proporciona suficiente informaci√≥n (o si no hubiera un valor inicial), especifica el tipo escribi√©ndolo despu√©s de la variable, separado por dos puntos.

```swift showLineNumbers {3} /: Double/
let enteroImplicito = 70
let doubleImplicito = 70.0
let doubleExplicito: Double = 70
```

<Callout type="experiment">
  Crea una constante con `Float` como su tipo expl√≠cito y un valor de `4`.
</Callout>

Los valores nunca se convierten a un tipo diferente impl√≠citamente. Si necesitas convertir un valor a un tipo diferente, debes crear ‚Äîde manera expl√≠cita‚Äî una instancia del tipo deseado.

```swift showLineNumbers {3} /String(ancho)/
let etiqueta = "El ancho es "
let ancho = 94
let anchoDeLaEtiqueta = etiqueta + String(ancho)
```

<Callout type="experiment">
  Prueba removiendo la conversi√≥n a `String` en la √∫ltima l√≠nea. ¬øCu√°l error
  aparece?
</Callout>

Hay una manera incluso m√°s sencilla de insertar valores en una cadena de texto ‚Äî escribe el valor en par√©ntesis, precedidos por una barra invertida (`\`). Por ejemplo:

```swift showLineNumbers {3, 4}
let manzanas = 3
let naranjas = 5
let totalManzanas = "Tengo \(manzanas) manzanas."
let totalFrutas = "Tengo \(manzanas + naranjas) frutas."
```

<Callout type="experiment">
  Usa `\()` para insertar una operaci√≥n con n√∫meros de coma flotante en una
  cadena de texto y para incluir el nombre de alguien en un saludo.
</Callout>

Usa tres comillas dobles para cadenas de texto que ocupen m√°s de una l√≠nea. La sangr√≠a (_indentation_) al inicio de cada l√≠nea de la cadena de texto es removida siempre y cuando concuerde con la sangr√≠a de las comillas de cierre. Por ejemplo:

```swift showLineNumbers
let cita = """
    Aun cuando hay espacios en blanco a la izquierda,
    las l√≠neas no contienen sangr√≠a en realidad.
        Excepto por esta l√≠nea.
    Las comillas dobles (") pueden aparecer sin escaparlas.

    Todav√≠a tengo \(manzanas + naranjas) frutas.
    """
```

Crea _arrays_ y diccionarios usando corchetes (`[]`) y accede a sus elementos referenciando su √≠ndice o clave en corchetes. Est√° permitido agregar una coma despu√©s del √∫ltimo elemento.

```swift showLineNumbers
var frutas = ["fresas", "peras", "mandarinas"]

frutas[1] = "uvas"

var ocupaciones = [
    "Manuel": "Capit√°n",
    "Carlos": "Mec√°nico"
]

ocupaciones["Julia"] = "Relaciones P√∫blicas"
```

Los _arrays_ crecen autom√°ticamente a medida que agregas elementos.

```swift showLineNumbers
frutas.append("moras")

print(frutas)
// Imprime "[fresas, uvas, mandarinas, moras]"
```

Tambi√©n se usan corchetes para crear un _array_ o un diccionario vac√≠os. Para un _array_, usa `[]` y, para un diccionario, usa `[:]`.

```swift showLineNumbers
frutas = []
ocupaciones = [:]
```

Si asignas un _array_ o un diccionario vac√≠os a una nueva variable, o a alg√∫n otro lugar donde no hay ninguna informaci√≥n sobre el tipo, tendr√°s que especificarlo.

```swift showLineNumbers
let arrayVacio: [String] = []
let diccionarioVacio: [String: Float] = [:]
```

## Flujo de control

Usa `if` y `switch` para crear condicionales, y usa `for-in`, `while`, y `repeat-while` para crear bucles. Los par√©ntesis alrededor de la condici√≥n o de la variable del bucle son opcionales. Las llaves alrededor del cuerpo son obligatorias.

```swift showLineNumbers {5-9}
let puntajesIndividuales = [75, 43, 103, 87, 12]
var puntajeDelEquipo = 0

for puntaje in puntajesIndividuales {
    if puntaje > 50 {
        puntajeDelEquipo += 3
    } else {
        puntajeDelEquipo += 1
    }
}

print(puntajeDelEquipo)
// Imprime "11"
```

En una instrucci√≥n `if`, el condicional debe ser una expresi√≥n de tipo booleano; esto significa, que una instrucci√≥n de la forma `if puntaje { ... }` es un error, ya que no se compara impl√≠citamente con cero.

Puede escribir `if` o `switch` despu√©s del signo igual (`=`) de una asignaci√≥n o despu√©s de `return`, para elegir un valor en funci√≥n de la condici√≥n.

```swift showLineNumbers {1-5} /= if/
let decoracionDelPuntaje = if puntajeDelEquipo > 50 {
    "üéâ"
} else {
    ""
}

print("Puntaje: ", puntajeDelEquipo, decoracionDelPuntaje)
// Imprime "Puntaje: 11 üéâ"
```

Puedes usar `if` y `let` en conjunto para lidiar con valores que podr√≠an no existir. Estos valores son representados como opcionales. Un valor opcional puede contener un valor o `nil` ‚Äîpara indicar la ausencia de un valor‚Äî. Agrega un signo de interrogaci√≥n (`?`) despu√©s del tipo de un valor para se√±alar dicho valor como opcional.

```swift showLineNumbers {1,6,9} /: String?/ /if let/
var cadenaOpcional: String? = "Hola"

print(cadenaOpcional == nil)
// Imprime "false"

var nombreOpcional: String? = "John Appleseed"
var saludo = "¬°Hola!"

if let nombre = nombreOpcional {
    saludo = "Hola, \(nombre)."
}
```

<Callout type="experiment">
  Cambia el valor de `nombreOpcional` a `nil`. ¬øCu√°l saludo obtienes? Agrega una
  cl√°usula `else` que defina un saludo diferente si `nombreOpcional` es `nil`.
</Callout>

Si el valor opcional es `nil`, el condicional eval√∫a a `false` y el c√≥digo en las llaves es ignorado. En caso contrario, se extrae el valor opcional y se le asigna a la constante despu√©s de `let`, lo cual hace que el valor obtenido est√© disponible dentro del bloque de c√≥digo.

Otra forma de manejar valores opcionales es proporcionarles un valor predeterminado mediante el uso del operador `??`. Si el valor opcional no existe, se usar√° el valor predeterminado en su lugar.

```swift showLineNumbers {3} /alias ?? nombreCompleto/
let alias: String? = nil
let nombreCompleto: String = "John Appleseed"
let saludoInformal = "Hola, \(alias ?? nombreCompleto)"
```

Puedes usar una sintaxis m√°s corta para extraer un valor al utilizar el mismo nombre para dicho valor extra√≠do.

```swift showLineNumbers {1,2}
if let alias {
    print("Hey, \(alias)")
}
// No imprime nada porque alias es nil.
```

Los bucles de tipo `switch` soportan cualquier tipo de datos as√≠ como una gran variedad de operaciones comparativas; estos no se limitan a enteros y pruebas de calidad.

```swift showLineNumbers
let vegetal = "pimiento rojo"

switch vegetal {
case "apio":
    print("Un par de frutos verdes m√°s y tendr√°s un buen batido.")
case "pepino", "cebolla":
    print("√ötiles para un buen sandwich.")
case let x where x.hasSuffix("pimiento"):
    print("¬øEs un \(x) picante?")
default:
    print("Todo sabe bien en una sopa.")
}
// Imprime "¬øEs un pimiento rojo picante?"
```

<Callout type="experiment">
  Remueve el caso `default`. ¬øCu√°l es el error que aparece?
</Callout>

Observa c√≥mo es posible usar `let` con un patr√≥n para asignar el valor que concuerde con dicho patr√≥n a una constante.

Una vez ejecutado el c√≥digo dentro del caso que concuerda, el programa abandona el bucle switch. La ejecuci√≥n no contin√∫a al siguiente caso, por lo que no es necesario indicar la salida del bucle expl√≠citamente al final del c√≥digo de cada caso.

Puedes usar `for-in` para iterar sobre los elementos de un diccionario al proporcionar un par de nombres que ser√°n usados para cada par llave-valor. Los diccionarios son colecciones sin un orden particular, por lo que se itera sobre sus llaves y valores de manera arbitraria.

```swift showLineNumbers {9,10}
let numerosInteresantes = [
    "Primos": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Cuadrados": [1, 4, 9, 16, 25]
]

var numeroMayor = 0

for (_, numeros) in numerosInteresantes {
    for numero in numeros {
        if numero > numeroMayor {
            numeroMayor = numero
        }
    }
}

print(numeroMayor)
// Imprime "25"
```

<Callout type="experiment">
  Reemplaza `_` por una variable con nombre y haz seguimiento del tipo de n√∫mero
  que resulta ser el mayor.
</Callout>

Usa `while` para repetir un bloque de c√≥digo hasta que se satisfaga una condici√≥n. La condici√≥n del bucle puede ir al final, para asegurar que este se ejecute al menos una vez.

```swift showLineNumbers {3-5,12-14} /while n < 100/ /while m < 100/
var n = 2

while n < 100 {
    n *= 2
}

print(n)
// Imprime "128"

var m = 2

repeat {
    m *= 2
} while m < 100

print(m)
// Imprime "128"
```

<Callout type="experiment">
  Cambia la condici√≥n de `m < 100` a `m < 0` para ver c√≥mo `while` y
  `repeat-while` se comportan de manera diferente cuando la condici√≥n del bucle
  es verdadera desde un inicio.
</Callout>

Es posible tener √≠ndices en un bucle al usar `..<` para crear un rango de √≠ndices.

```swift showLineNumbers {3} /0..<4/
var total = 0

for i in 0..<4 {
    total += i
}

print(total)
// Imprime "6"
```

Usa `..<` para crear un rango que omita el valor superior, y usa `...` para crear uno que incluya ambos valores.

## Funciones y clausuras

Usa `func` para declarar una funci√≥n. Para llamar una funci√≥n, escribe una lista de argumentos en par√©ntesis despu√©s de su nombre. Usa `->` para separar el nombre de los par√°metros y sus tipos del tipo que devuelve la funci√≥n.

```swift showLineNumbers {1,5} /func/ /->/
func saludar(persona: String, dia: String) -> String {
    return "Hola, \(persona), hoy es \(dia)."
}

saludar(persona: "Bob", dia: "Martes")
```

<Callout type="experiment">
  Remueve el par√°metro `dia`. Agrega un par√°metro que incluya el almuerzo
  especial de hoy en el saludo.
</Callout>

Por defecto, las funciones usan los nombres de sus par√°metros como etiquetas para sus argumentos. Crea tu propia etiqueta para un argumento anteponi√©ndola al nombre del par√°metro, o agrega `_` para no usar una etiqueta para un argumento.

```swift showLineNumbers {1, 5} /_/ /en/
func saludar(_ persona: String, en dia: String) -> String {
    return "Hola, \(persona), hoy es \(dia)."
}

saludar("Juan", en: "Miercoles")
```

Usa una tupla para crear un valor compuesto; por ejemplo, para devolver m√∫ltiples valores desde una funci√≥n. Los elementos de una tupla se pueden referenciar bien sea por nombre o por n√∫mero.

```swift showLineNumbers {1, 17} /-> (min: Int, max: Int, suma: Int)/
func calcularEstadisticas(puntajes: [Int]) -> (min: Int, max: Int, suma: Int) {
    var min = puntajes[0]
    var max = puntajes[0]
    var suma = 0

    for puntaje in puntajes {

        if puntaje > max {
            max = puntaje
        } else if puntaje < min {
            min = puntaje
        }

        suma += puntaje
    }

    return (min, max, suma)
}

let estadisticas = calcularEstadisticas(puntajes: [5, 3, 100, 3, 9])

print(estadisticas.suma)
// Imprime "120"

print(estadisticas.2)
// Imprime "120"
```

Las funciones pueden anidarse. Las funciones anidadas tienen acceso a variables que hayan sido declaradas en la funci√≥n externa. Puedes usar funciones anidadas para organizar c√≥digo que resulta extenso o complejo.

```swift showLineNumbers
func devolverQuince() -> Int {
    var y = 10

    func agregar() {
        y += 5
    }

    agregar()

    return y
}

devolverQuince()
```

Las funciones son un tipo de primera clase. Esto quiere decir que una funci√≥n puede devolver otra funci√≥n como su valor.

```swift showLineNumbers {1, 6} /-> ((Int) -> Int)/
func crearIncrementador() -> ((Int) -> Int) {
    func agregarUno(numero: Int) -> Int {
        return 1 + numero
    }

    return agregarUno
}

var incrementar = crearIncrementador()

incrementar(7)
```

Una funci√≥n puede tomar a otra funci√≥n como uno de sus argumentos.

```swift showLineNumbers {1,18} /condicion: (Int) -> Bool/ /condicion: menorQueDiez/
func coincideAlguno(lista: [Int], condicion: (Int) -> Bool) -> Bool {

    for elemento in lista {
        if condicion(elemento) {
            return true
        }
    }

    return false
}

func menorQueDiez(numero: Int) -> Bool {
    return numero < 10
}

var numeros = [20, 19, 7, 12]

coincideAlguno(lista: numeros, condicion: menorQueDiez)
```

Las funciones son, en realidad, un caso especial de las clausuras: bloques de c√≥digo que pueden ser llamados m√°s tarde. El c√≥digo en una clausura tiene acceso a elementos como variables y funciones que est√°n disponibles en el √°mbito en el cual se cre√≥ la clausura, incluso cuando la clausura se encuentra en un √°mbito diferente al momento de ejecutarse; ya has visto un ejemplo de esto con las funciones anidadas. Puedes crear una clausura an√≥nima al encerrar el c√≥digo en llaves (`{}`). Usa `in` para separar los argumentos y el tipo devuelto por la funci√≥n del cuerpo de la funci√≥n.

```swift showLineNumbers /{/ /}/ /in/
numeros.map({ (numero: Int) -> Int in
    let resultado = 3 * numero

    return resultado
})
```

<Callout type="experiment">
  Reescribe la clausura de manera que devuelva cero para todos los n√∫meros
  impares.
</Callout>

Existen muchas maneras de crear una clausura de forma m√°s concisa. Cuando se conoce el tipo de una clausura, como es el caso de un _callback_ para un delegado, puedes omitir el tipo de sus par√°metros, el tipo devuelto, o de ambos. Las clausuras de una sola sentencia devuelven el valor de su √∫nica sentencia de manera impl√≠cita.

```swift showLineNumbers {1} / numero in 3 * numero /
let numerosMapeados = numeros.map({ numero in 3 * numero })

print(numerosMapeados)
// Imprime "[60, 57, 21, 36]"
```

Puedes referenciar par√°metros por n√∫mero en vez de nombre; este enfoque es, especialmente, √∫til para clausuras muy concisas. Una clausura que se pasa como el √∫ltimo argumento de una funci√≥n puede aparecer inmediatamente despu√©s de los par√©ntesis. Cuando una clausura es el √∫nico argumento de una funci√≥n, puedes omitir los par√©ntesis por completo.

```swift showLineNumbers {1} / $0 > $1 /
let numerosOrdenados = numeros.sorted { $0 > $1 }

print(numerosOrdenados)
// Imprime "[20, 19, 12, 7]"
```

## Objetos y clases

Usa `class` seguido del nombre de la clase para crear una clase. Para declarar una propiedad de una clase, se escribe igual que al declarar una constante o variable, excepto que esta existir√≠a en el contexto de una clase. Similarmente, la declaraci√≥n de m√©todos y funciones se hace de la misma forma.

```swift showLineNumbers
class Figura {
    var numeroDeLados = 0

    func descripcionBasica() -> String {
        return "Una figura con \(numeroDeLados) lados."
    }
}
```

<Callout type="experiment">
  Agrega una propiedad constante con `let` y otro m√©todo que tome un argumento.
</Callout>

Crea una instancia de una clase al poner par√©ntesis despu√©s del nombre de la clase. Usa sintaxis de punto para acceder a las propiedades y m√©todos de la instancia.

```swift showLineNumbers
var figura = Figura()
figura.numeroDeLados = 7
var descripcionFigura = descripcionBasica()
```

A esta versi√≥n de la clase `Figura` le hace falta algo importante: un inicializador que establezca la clase al crear una instancia. Usa `init` para crear uno.

```swift showLineNumbers {5-7}
class FiguraConNombre {
    var numeroDeLados: Int = 0
    var nombre: String

    init(nombre: String) {
        self.nombre = nombre
    }

    func descripcionBasica() -> String {
        return "Una figura con \(numeroDeLados) lados."
    }
}
```

Observa c√≥mo se usa `self` para diferenciar la propiedad `nombre` del argumento (del inicializador) `nombre`. Al crear una instancia de una clase, los argumentos del inicializador se pasan como cuando se llama una funci√≥n. Cada propiedad requiere que se le asigne un valor, bien sea al declararla (como con `numeroDeLados`) o en el inicializador (como con `nombre`).

Usa `deinit` para crear un ¬´desinicializador¬ª (del ingl√©s _deinitializer_) si necesitas llevar a cabo alguna limpieza antes de que el objeto sea ¬´desasignado¬ª (del ingl√©s _deallocated_).

Las subclases incluyen el nombre de su s√∫perclase despu√©s de su propio nombre, separados por una coma. No es requerimiento de las clases pasar ninguna clase base est√°ndar a las subclases, por lo que puedes incluir u omitir una s√∫perclase si as√≠ lo requieres.

Aquellos m√©todos de una subclase que redefinen la implementaci√≥n de una s√∫perclase, se marcan con `override`; redefinir un m√©todo por accidente, sin usar `override`, es detectado por el compilador como un error. El compilador tambi√©n detecta m√©todos con `override` que no redefinen ning√∫n m√©todo de la s√∫perclase.

```swift showLineNumbers {1, 5, 7, 9, 16, 21} /Cuadrado: FiguraConNombre/ /override/
class Cuadrado: FiguraConNombre {
    var longitudLado: Double

    init(longitudLado: Double, nombre: String) {
        self.longitudLado = longitudLado

        super.init(nombre: nombre)

        numeroDeLados = 4
    }

    func area() -> Double {
        return longitudLado * longitudLado
    }

    override func descripcionBasica() -> String {
        return "Un cuadrado con lados de longitud \(longitudLado)."
    }
}

let prueba = Cuadrado(longitudLado: 5.2, nombre: "cuadrado de prueba")

prueba.area()
prueba.descripcionBasica()
```

<Callout type="experiment">
  Crea otra subclase de `FiguraConNombre` llamada `Circulo`, que tome un radio y
  un nombre como argumentos de su inicializador. Implementa los m√©todos `area()`
  y `descripcionBasica()` en la clase `Circulo`.
</Callout>

Aparte de ser simples propiedades que se pueden almacenar, las propiedades pueden tener un _getter_ y un _setter_.

```swift showLineNumbers {13-15, 17-19}
class TrianguloEquilatero: FiguraConNombre {
    var longitudLado: Double = 0.0

    init(longitudLado: Double, nombre: String) {
        self.longitudLado = longitudLado

        super.init(nombre: nombre)

        numeroDeLados = 3
    }

    var perimetro: Double {
        get {
            return 3.0 * longitudLado
        }

        set {
            longitudLado = newValue / 3.0
        }
    }

    override func descripcionBasica() -> String {
        return "Un tri√°ngulo equil√°tero con lados de longitud \(longitudLado)."
    }
}

var triangulo = TrianguloEquilatero(longitudLado: 3.1, nombre: "un tri√°ngulo")

print(triangulo.perimetro)
// Imprime "9.3"

triangulo.perimetro = 9.9

print(triangulo.longitudLado)
// Imprime "3.3000000000000003"
```

En el _setter_ de `perimetro`, el nuevo valor tiene el nombre impl√≠cito de `newValue`. Puedes proporcionar un nombre expl√≠cito en par√©ntesis despu√©s de `set`.

Observa c√≥mo el inicializador de la clase `TrianguloEquilatero` tiene tres pasos diferentes:

1. Establecer el valor de las propiedades declaradas por la subclase.
2. Llamar al inicializador de la s√∫perclase.
3. Cambiar el valor de las propiedades definidas por la s√∫perclase. Cualquier otra configuraci√≥n adicional que use m√©todos, _getters_, o _setters_ tambi√©n puede llevarse a cabo en este punto.

Si no necesitas calcular la propiedad, pero igual necesitas proporcionar c√≥digo que se ejecuta antes y despu√©s de establecer un nuevo valor, usa `willSet` and `didSet`. El c√≥digo que proporciones se ejecutar√° cada vez que el valor cambie fuera del inicializador. Por ejemplo, la clase a continuaci√≥n se asegura de que la longitud de los lados de su tri√°ngulo siempre sea la misma que la longitud de los lados de su cuadrado.

```swift showLineNumbers {3-5, 9-11}
class TrianguloYCuadrado {
    var triangulo: TrianguloEquilatero {
        willSet {
            cuadrado.longitudLado = newValue.longitudLado
        }
    }

    var cuadrado: Cuadrado {
        willSet {
            triangulo.longitudLado = newValue.longitudLado
        }
    }

    init(tamano: Double, nombre: String) {
        cuadrado = Cuadrado(longitudLado: tamano, nombre: nombre)
        triangulo = TrianguloEquilatero(longitudLado: tamano, nombre: nombre)
    }
}

var trianguloYCuadrado = TrianguloYCuadrado(size: 10, nombre: "otra figura de prueba")

print(trianguloYCuadrado.cuadrado.longitudLado)
// Imprime "10.0"

print(trianguloYCuadrado.triangulo.longitudLado)
// Imprime "10.0"

trianguloYCuadrado.cuadrado = Cuadrado(longitudLado: 50, nombre: "cuadrado m√°s grande")

print(trianguloYCuadrado.triangulo.longitudLado)
// Imprime "50.0"
```

Al trabajar con valores opcionales, puedes escribir `?` antes de operaciones como m√©todos, propiedades, y _subscripting_. Si el valor antes de `?` es `nil`, todo lo que sigue a `?` es ignorado y el valor de toda la expresi√≥n es `nil`. En caso contrario, se obtiene el valor opcional y todo lo que sigue a `?` opera sobre el valor obtenido. En ambos casos, el valor de toda la expresi√≥n es un valor opcional.

```swift showLineNumbers {2} /?./
let cuadradoOpcional: Cuadrado? = Cuadrado(longitudLado: 2.5, nombre: "cuadrado opcional")
let longitudLado = cuadradoOpcional?.longitudLado
```

## Enumeraciones y estructuras

Utiliza `enum` para crear una enumeraci√≥n. Al igual que las clases y todos los dem√°s tipos con nombre, las enumeraciones pueden tener m√©todos asociados con ellas.

```swift showLineNumbers
enum Escala: Int {
    case _as = 1
    case dos, tres, cuatro, cinco, seis, siete, ocho, nueve, diez
    case jack, reina, rey

    func descripcionBasica() -> String {
        switch self {
        case ._as:
            return "as"
        case .jack:
            return "jack"
        case .reina:
            return "reina"
        case .rey:
            return "rey"
        default:
            return String(self.rawValue)
        }
    }
}

let _as = Escala._as
let valorBrutoDeAs = _as.rawValue
```

<Callout type="experiment">
  Crea una funci√≥n que compare dos valores de tipo `Escala` comparando sus
  valores brutos.
</Callout>

De manera predeterminada, Swift asigna los valores brutos comenzando por cero y aumentando en uno cada vez, pero es posible cambiar dicho comportamiento al especificar valores expl√≠citamente. En el ejemplo anterior, a `Ace` se le asigna expl√≠citamente un valor bruto de `1` y el resto de los valores brutos se asignan en orden. Tambi√©n es posible utilizar cadenas de texto o n√∫meros de coma flotante como el tipo bruto de una enumeraci√≥n. Usa la propiedad `rawValue` para acceder al valor bruto del caso de una enumeraci√≥n.

Utiliza el inicializador `init?(rawValue:)` para crear una instancia de una enumeraci√≥n a partir de un valor bruto. Este inicializador devuelve el caso (de la enumeraci√≥n) que coincida con el valor bruto o `nil` si no existe tal enumeraci√≥n `Escala`.

```swift showLineNumbers {1} /Escala(rawValue: 3)/
if let escalaTransformada = Escala(rawValue: 3) {
    let descripcionDelTres = escalaTransformada.descripcionSimple()
}
```

Los valores de los casos de una enumeraci√≥n son valores reales, no solo otra forma de escribir sus valores brutos. De hecho, en los casos en los que no existe un valor bruto significativo, no es necesario que proporciones uno.

```swift showLineNumbers
enum Palo {
    case picas, corazones, diamantes, treboles

    func descripcionBasica() -> String {
        switch self {
        case .picas:
            return "picas"
        case .corazones:
            return "corazones"
        case .diamantes:
            return "diamantes"
        case .treboles:
            return "treboles"
        }
    }
}

let corazones = Palo.corazones
let descripcionDeCorazones = corazones.descripcionBasica()
```

<Callout type="experiment">
  Crea un m√©todo `color()` para la enumeraci√≥n `Palo` que devuelva "negro" para
  picas y tr√©boles, y "rojo" para corazones y diamantes.
</Callout>

F√≠jate en las dos formas en que se referenci√≥ el caso `corazones` de la enumeraci√≥n: al asignar un valor a la constante `corazones`, el caso `Palo.corazones` se referencia por su nombre completo porque la constante no tiene un tipo especificado expl√≠citamente. Dentro del bucle switch, el caso se referencia mediante la forma abreviada `.corazones` porque ya sabemos que el valor de `self` es un tipo de palo. Puedes utilizar la forma abreviada siempre que el tipo del valor ya sea conocido.

Si una enumeraci√≥n tiene valores brutos, se establece que dicho valores forman parte de la declaraci√≥n, lo que significa que cada instancia de un caso de enumeraci√≥n en particular siempre tendr√° el mismo valor bruto. Otra opci√≥n para los casos de enumeraci√≥n es tener valores asociados con el caso; estos valores se determinan al crear la instancia y pueden ser diferentes para cada instancia de un caso de enumeraci√≥n. Puedes ver los valores asociados como si actuaran como propiedades almacenadas de la instancia del caso de enumeraci√≥n. Por ejemplo, considera el caso en el que se le pide a un servidor las horas de salida y puesta del sol. El servidor responder√° con la informaci√≥n solicitada o responder√° con una descripci√≥n de lo que haya salido mal.

```swift showLineNumbers
enum RespuestaServidor {
    case resultado(String, String)
    case falla(String)
}

let logro = RespuestaServidor.resultado("6:00 am", "6:00 pm")
let error = RespuestaServidor.falla("Se han agotado los recursos.")

switch logro {
case let .resultado(amanecer, atardecer):
    print("El amanecer es a las \(amanecer) y el atardecer es a las \(atardecer).")
case let .falla(mensaje):
    print("Error...  \(mensaje)")
}
// Imprime "El amanecer es a las 6:00 am y el atardecer es a las 6:00 pm."
```

<Callout type="experiment">
  Agrega un tercer caso a `RespuestaServidor` y al bucle _switch_.
</Callout>

Observa c√≥mo las horas de amanecer y atardecer se extraen del valor `RespuestaServidor` como parte de la comparaci√≥n del valor con los casos del bucle switch.

Usa `struct` para crear una estructura. Las estructuras soportan muchos de los mismos comportamientos que las clases, incluyendo m√©todos e inicializadores. Una de las diferencias m√°s importantes entre estructuras y clases es que las estructuras siempre resultan siendo copiadas al usarlas a lo largo de tu c√≥digo, mientras que las clases resultan siendo pasadas como referencias.

```swift showLineNumbers
struct Carta {
    var escala: Escala
    var palo: Palo

    func descripcionBasica() -> String {
        return "El \(escala.descripcionBasica()) de \(palo.descripcionBasica())."
    }
}

let tresDePicas = Carta(escala: .tres, palo: .picas)
let descripcionDelTresDePicas = tresDePicas.descripcionBasica()
```

<Callout type="experiment">
  Crea una funci√≥n que devuelva un _array_ que contenga una baraja completa de
  cartas, con una carta de cada combinaci√≥n de escala y palo.
</Callout>

## Concurrencia

Usa `async` para marcar una funci√≥n que se ejecuta de manera as√≠ncrona:

```swift showLineNumbers {1} /async/
func obtenerIdDeUsuario(desde servidor: String) async -> Int {
    if servidor == "principal" {
        return 97
    }

    return 501
}
```

Para marcar el llamado a una funci√≥n as√≠ncrona, agrega la palabra clave `await` despu√©s de la invocaci√≥n de la funci√≥n:

```swift showLineNumbers {2} /await/
func obtenerNombreDeUsuario(desde servidor: String) async -> String {
    let idDeUsuario = await obtenerIdDeUsuario(desde: servidor)

    if idDeUsuario == 501 {
        return "John Appleseed"
    }

    return "Visitante"
}
```

Usa `async let` para llamar a una funci√≥n as√≠ncrona permiti√©ndole ejecutarse en paralelo con otro c√≥digo as√≠ncrono. Si necesitas usar el valor que devuelve, utiliza `await`:

```swift showLineNumbers {2, 3, 4} /async let/ /await/
func conectarUsuario(a servidor: String) async {
    async let idDeUsuario = obtenerIdDeUsuario(desde: servidor)
    async let nombreDeUsuario = obtenerNombreDeUsuario(desde: servidor)
    let saludo = await "Hola, \(nombreDeUsuario), ID de usuario \(idDeUsuario)"

    print(saludo)
}
```

Usa `Task` para invocar funciones as√≠ncronas desde c√≥digo sincr√≥nico, sin tener que esperar a que estas devuelvan su valor.

```swift showLineNumbers
Task {
    await conectarUsuario(a: "principal")
}
// Imprime "Hola, Visitante, ID de usuario 97"
```

## Protocolos y Extensiones

Usa `protocol` para declarar un protocolo.

```swift showLineNumbers {1} /protocol/
protocol ProtocoloEjemplo {
    var descripcionBasica: String { get }

    mutating func ajustar()
}
```

Las clases, enumeraciones, y estructuras pueden adoptar protocolos.

```swift showLineNumbers {1, 16}
class ClaseBasica: ProtocoloEjemplo {
    var descripcionBasica: String = "Una clase muy b√°sica."
    var otraPropiedad: Int = 69105

    func ajustar() {
        descripcionBasica += " Ahora 100% ajustada."
    }
}

var a = ClaseBasica()

a.ajustar()

let descripcionDeA = a.descripcionBasica

struct EstructuraBasica: ProtocoloEjemplo {
    var descripcionBasica: String = "Una estructura b√°sica"

    mutating func ajustar() {
        descripcionBasica += " (ajustada)"
    }
}

var b = EstructuraBasica()

b.ajustar()

let descripcionDeB = b.descripcionBasica
```

<Callout type="experiment">
  Agrega otro requerimiento a `ProtocoloEjemplo`. ¬øCu√°les cambios debes hacer en
  `ClaseBasica` y `EstructuraBasica` para que estas est√©n en conformidad con el
  protocolo?
</Callout>

Nota el uso de la palabra clave `mutating` en la declaraci√≥n de `EstructuraBasica` para marcar un m√©todo que modifica la estructura. En la declaraci√≥n de `ClaseBasica` no se necesita que ninguno de sus m√©todos est√© marcado como modificador ya que los m√©todos de una clase siempre pueden modificar la clase misma.

Utiliza `extension` para agregar funcionalidad a un tipo existente, como nuevos m√©todos y propiedades calculadas. Puedes usar una extensi√≥n para hacer que un tipo se ajuste a un protocolo, bien sea un tipo que se declara en otro lugar, o incluso un tipo que se importa de una biblioteca o _framework_.

```swift showLineNumbers
extension Int: ProtocoloEjemplo {
    var descripcionBasica: String {
        return "El n√∫mero \(self)"
    }

    mutating func ajustar() {
        self += 42
    }
}

print(7.descripcionBasica)
// Imprime "El n√∫mero 7"
```

<Callout type="experiment">
  Crea una extensi√≥n para el tipo `Double` que agregue la propiedad
  `valorAbsoluto`.
</Callout>

Puedes usar el nombre de un protocolo como cualquier otro tipo con nombre; por ejemplo, para crear una colecci√≥n de objetos que tiene tipos diferentes, pero que todos se ajusten a un solo protocolo. Al trabajar con valores cuyo tipo es un tipo de protocolo, los m√©todos externos a la definici√≥n del protocolo no estar√°n disponibles.

```swift showLineNumbers
let valorProtocolo: ProtocoloEjemplo = a

print(valorProtocolo.descripcionBasica)
// Imprime "Una clase muy b√°sica. Ahora 100% ajustada."
// print(valorProtocolo.otraPropiedad)  // Habilita esta l√≠nea para ver el error
```

Aun cuando el tipo de _runtime_ de la variable `valorProtocolo` es del tipo `ClaseBasica`, el compilador lo trata como el tipo dado de `ProtocoloEjemplo`. Esto significa que no puedes acceder, de manera accidental, a m√©todos o propiedades que la clase implementa adem√°s de su conformidad con el protocolo.

## Manejo de Errores

Puedes representar errores mediante cualquier tipo que adopte el protocolo `Error`.

```swift showLineNumbers
enum ErrorImpresora: Error {
    case papelAgotado
    case tonerAgotado
    case enLlamas
}
```

Usa `throw` para arrojar un error y `throws` para marcar una funci√≥n que puede arrojar un error. Si arrojas un error en una funci√≥n, la funci√≥n se interrumpe inmediatamente y el c√≥digo que llam√≥ a la funci√≥n se encargar√° de manejar el error.

```swift showLineNumbers {1, 3} /throw/ /throws/
func enviar(tarea: Int, impresoraDestino nombreImpresora: String) throws -> String {
    if nombreImpresora == "Nunca Tiene Toner" {
        throw ErrorImpresora.tonerAgotado
    }

    return "Tarea enviada"
}
```

Hay muchas maneras de manejar los errores. Una forma es usando `do-catch`. Dentro del bloque `do`, marcas el c√≥digo que puede arrojar un error escribiendo `try` delante de √©l. Dentro del bloque `catch`, al error se le asigna autom√°ticamente el nombre `error`, a menos que le asignes un nombre diferente.

```swift showLineNumbersn{1, 5} /try/
do {
    let respuestaImpresora = try enviar(tarea: 1040, impresoraDestino: "Bi Sheng")

    print(respuestaImpresora)
} catch {
    print(error)
}
// Imprime "Tarea enviada"
```

<Callout type="experiment">
  Cambia el nombre de la impresora a `¬´Nunca Tiene Toner¬ª`, de manera que la
  funci√≥n `enviar(tarea:impresoraDestino:)` arroje un error.
</Callout>

Puedes usar m√∫ltiples bloques `catch` que manejen errores espec√≠ficos. Para esto, define un patr√≥n despu√©s de `catch` al igual que lo haces despu√©s de `case` en un bucle switch.

```swift showLineNumbers {5-11}
do {
    let respuestaImpresora = try enviar(tarea: 1440, impresoraDestino: "Gutenberg")

    print(respuestaImpresora)
} catch ErrorImpresora.enLlamas {
    print("Dejar√© esto por aqu√≠, con el resto del fuego.")
} catch let errorImpresora as ErrorImpresora {
    print("Error impresora: \(errorImpresora).")
} catch {
    print(error)
}
// Imprime "Tarea enviada"
```

<Callout type="experiment">
  Agrega c√≥digo de manera que se arroje un error dentro del bloque `do`. ¬øQu√©
  tipo de error es necesario arrojar para que este sea manejado por el primer
  bloque `catch`? ¬øQu√© tal con el segundo y tercer bloque?
</Callout>

Otra forma de manejar los errores es usando `try?` para convertir el resultado en un opcional. Si la funci√≥n arroja un error, el error espec√≠fico se descarta y el resultado es `nil`. De lo contrario, el resultado es un opcional que contiene el valor que devolvi√≥ la funci√≥n.

```swift showLineNumbers
let exitoImpresora = try? enviar(tarea: 1884, impresoraDestino: "Mergenthaler")
let fallaImpresora = try? enviar(tarea: 1885, impresoraDestino: "Nunca Tiene Toner")
```

Usa `defer` para crear un bloque de c√≥digo que se ejecute despu√©s de todo el c√≥digo de una funci√≥n, justo antes de que la funci√≥n devuelva su valor. El c√≥digo se ejecuta sin importar que la funci√≥n arroje un error. Puedes utilizar `defer` para escribir c√≥digos de configuraci√≥n y limpieza, uno al lado del otro, aun cuando estos deban ejecutarse en momentos diferentes.

```swift showLineNumbers {7-9}
var refrigeradorEstaAbierto = false
let contenidoRefrigerador = ["leche", "huevos", "sobras"]

func hayEnElRefrigerador(_ alimento: String) -> Bool {
    refrigeradorEstaAbierto = true

    defer {
        refrigeradorEstaAbierto = false
    }

    let resultado = contenidoRefrigerador.contains(alimento)

    return resultado
}

hayEnElRefrigerador("banana")

print(refrigeradorEstaAbierto)
// Imprime "false"
```

## Gen√©ricos

Escribe un nombre entre par√©ntesis angulares (`<>`) para crear una funci√≥n o tipo gen√©rico.

```swift showLineNumbers {1} /crearArray<Item>/
func crearArray<Item>(repitiendo item: Item, numeroDeVeces: Int) -> [Item] {
    var resultado: [Item] = []

    for _ in 0..<numeroDeVeces {
        resultado.append(item)
    }

    return resultado
}

crearArray(repitiendo: "toc", numeroDeVeces: 4)
```

Tambi√©n puedes crear formas gen√©ricas de funciones y m√©todos, como tambi√©n de clases, enumeraciones, y estructuras.

```swift showLineNumbers
// Reimplementa el tipo opcional de la librer√≠a est√°ndar de Swift
enum OptionalValue<Wrapped> {
    case none
    case some(Wrapped)
}

var posibleEntero: OptionalValue<Int> = .none

posibleEntero = .some(100)
```

Utiliza `where` justo antes del cuerpo de la funci√≥n para especificar una lista de requerimientos; por ejemplo, para requerir el tipo para implementar un protocolo, para requerir que dos tipos sean el mismo, o para requerir que una clase tenga una s√∫perclase en particular.

```swift showLineNumbers {2}
func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
    where T.Element: Equatable, T.Element == U.Element
{
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }

    return false
}

anyCommonElements([1, 2, 3], [3])
```

<Callout type="experiment">
  Modifica la funci√≥n `anyCommonElements(_:_:)` para crear una funci√≥n que
  devuelva un _array_ de los elementos que dos secuencias cualesquiera tienen en
  com√∫n.
</Callout>

Escribir `<T: Equatable>` es igual a escribir `<T> ... where T: Equatable`.


<Callout type="beta">
  Esta documentaci√≥n contiene informaci√≥n preliminar sobre una API o tecnolog√≠a
  en desarrollo. Esta informaci√≥n est√° sujeta a cambios, y todo software
  implementado en conformidad con esta documentaci√≥n debe ser testeado con el
  software final del sistema operativo.

  Conoce m√°s acerca del uso de [software beta de Apple](https://developer.apple.com/es/support/beta-software/).
</Callout>

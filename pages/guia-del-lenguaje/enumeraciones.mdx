---
title: Enumeraciones
---

import CodeSnippet from '../../components/CodeSnippet.js'
import Callout from '../../components/Callout.js'

# Enumeraciones

Una _enumeración_ define un tipo común para un grupo de valores realaciondos y le permite trabajar con esos valores de forma segura utilizando tipos de datos verificados.

Si está familiarizado con lenguaje C, sabrá que las enumeraciones de C asignan nombres relacionados a un conjunto de valores enteros. Las enumeraciones en Swift son mucho más flexibles y no tienen que proporcionar un valor para cada caso de la enumeración. Si se proporciona un valor (conocido como _raw o predeterminado_ ) para cada caso de enumeración, el valor puede ser una cadena, un carácter o un valor de cualquier tipo entero o de punto flotante.

Alternativamente, los casos de enumeración pueden especificar valores asociados de cualquier tipo que se almacenarán junto con cada valor de caso diferente, como lo hacen las uniones o variantes en otros idiomas. Usted puede definir un conjunto común de casos relacionados como parte de una enumeración, cada uno de los cuales tiene un conjunto diferente de valores de tipos apropiados asociados.

Las enumeraciones en Swift son tipos de primera clase en su propio derecho. Adopan muchas características tradicionalmente soportadas solamente por clases, talas como propiedades calculadas para proporcionar información adicional acerca de el valor actual de la enumeración e instancias de métodos para proporcionar funcionalidad relacionada a los valores que representa la enumeración.  Las enumeraciones también pueden definir inicializadores para proporcionar un valor de caso inicial; se pueden extender para expandir su funcionalidad más allá de la implementación original; y pueden ajustarse a los protocolos para proporcionar una funcionalidad estándar. 

Para más información de estas características, vea [Propiedades](./propiedades), [Métodos](./metodos), [Inicialización](./inicializacion), [Extensiones](./extensiones), and [Protocolos](./protocolos).

## Enumeración: Sintáxis

Puede declarar enumeraciones con la palabra reservada `enum` y poner la definición completa entre un par de llaves:

<CodeSnippet>
  {`enum AlgunaEnumeration {
    // la definición de la enumeración va aquí
}`}
</CodeSnippet>

Aquí está un ejemplo para los cuatro puntos principales de una brújula:

<CodeSnippet>
  {`enum PuntoCardinal {
    case norte
    case sur
    case este
    case oeste
}`}
</CodeSnippet>

Los valores definidos en una enumeración (tales como `norte`, `sur`, `este`, y `oeste`) son sus _casos de enumeración_. Se usa la palabra reservada  `case` para definir un nuevo caso de la enumeración.

<Callout>
  En Swift los casos de enumeración no tienen un valor entero asignado por default, a diferencia
  de lenguajes como C y Objective-C. En el ejemplo anterior de  `PuntoCardinal`,
  `norte`, `sur`, `este`, y `oeste` no corresponden a los valores `0`, `1`, `2`, y
  `3`. Por el contrario, los diferentes casos de la enumeración tienen su propio valor,
  con un explicitamente definido en  `PuntoCardinal`.
</Callout>

Se pueden declarar múlltiples casos en una sola línea, separados por comas:

<CodeSnippet>
  {`enum Planeta {
    case mercurio, venus, tierra, marte, jupiter, saturno, urano, neptuno
}`}
</CodeSnippet>

Cada declaración de una enumeración define un nuevo tipo. Como los otros tipos en Swift, sus nombre (tales como `PuntoCardinal` and `Planeta`) inician con una letra mayúscula. Dé a los tipos de enumeración nombres singulares en lugar de plurales, para que se lean como evidentes:


<CodeSnippet>{`var avanzarEnDireccion = PuntoCardinal.norte`}</CodeSnippet>

El tipo de  `avanzarEnDireccion` se infiere cuando es inicializado con uno de los posibles valores de `PuntoCardinal`. Una vez que  `avanzarEnDireccion` es declarado como un  `PuntoCardinal`, se puede cambiar a un diferente valor de `PuntoCardinal` de forma corte usando un punto la sintaxis es:

<CodeSnippet>{`avanzarEnDireccion = .este`}</CodeSnippet>

El tipo de `avanzarEnDireccion` ya se conoce, por lo tanto se puede asiganar el otro tipo cuando se asigna su valor. Esto hace que el código sea muy legible cuando se trabaja con valores de enumeración escritos explícitamente.

 ## Utilización de los valores de una Enumeración en una sentencia switch

Se puede busca la coincidencia de los valores individuales de una enumeración con una sentencia`switch:

<CodeSnippet>
  {`avanzarEnDireccion = .sur\n
switch avanzarEnDireccion {
case .norte:
    print("Muchos planetas tienen un norte")
case .sur:
    print("Mira los pingüinos")
case .este:
    print("Donde nace el sol")
case .oeste:
    print("donde el cielo es azul")
}
// Prints "Mira los pingüinos"`}
</CodeSnippet>

El código se puede leer como:

“Considerando del valor de `avanzarEnDireccion`. En caso de que sea `.norte`, imprime `"Muchos planetas tienen un norte"`. En caso de que sea igula a `.sur`, imprime `"Mira los pingüinos"`.”

…y así sucesivamente.

Como se describe en [Flujos de Control](./flujo-de-control), una sentencia `switch`  debe ser exhaustiva al considerar los casos de una enumeración. Si se omite el caso para `.oeste`,  este código no compila, porque no considera la lista completa de casos de PuntoCardinal. Requerir exhaustividad garantiza que los casos de enumeración no se omitan accidentalmente.

Cuando no sea apropiado proporcionar un `case` para cada caso de la enumeración, se puede proporcionar un caso `default` para cubrir cualquier caso que no se use explícitamente:

<CodeSnippet>
  {`let algunPlaneta = Planeta.tierra\n
switch algunPlaneta {
case .tierra:
    print("Mayoritariamente inofensivo")
default:
    print("No es un lugar seguro para los humanos")
}
// Prints "Mayoritariamente inofensivo"`}
</CodeSnippet>

## Iterando sobre los casos de una Enumeración

Para algunas enumeraciones, es útil tener una colección de todos los casos de esa enumeración. Para agregar esta funcionalidada se agrega `: CaseIterable` después del nombre de la enumeración. Swift expone una colección de todos los casos de la enumeración en la propiedad `allCases`. Aquí hay un ejemplo:

<CodeSnippet>
  {`enum Bebida: CaseIterable {
    case cafe, te, jugo
}\n
let numeroDeOpciones = Bebida.allCases.count
print("\\(numeroDeOpciones) bebidas disponibles")
// Prints "3 bebidas disponibles"`}
</CodeSnippet>

En el ejemplo anterior, se utiliza `Bebida.allCases` para acceder a una colección que contiene todos los casos de la enumeración `Bebida`. Se puede usar `allCases` como cualquier otra colección: los elementos de la colección son instancias del tipo de enumeración, por lo que en este caso son valores de `Bebida`. El ejemplo anterior cuenta cuántos casos hay, y el siguiente ejemplo usa un ciclo `for-in` para iterar sobre todos los casos.


<CodeSnippet>
  {`for bebida in Bebida.allCases {
    print(bebida)
}
// cafe
// te
// jugo`}
</CodeSnippet>

La sintaxis utilizada en los ejemplos anteriores define la enumeración conforme al protocolo [CaseIterable](https://developer.apple.com/documentation/swift/caseiterable). Para obtener información sobre los protocolos, consulte [Protocolos](./protocolos).

## Valores Asociados

Los ejemplos de la sección anterior muestran cómo los casos de una enumeración son un valor definido (y tipado) por sí mismo. Puede establecer una constante o variable en `Planeta.tierra` y verificar este valor más adelante. Sin embargo, a veces es útil poder almacenar valores de otros tipos junto con estos valores de casos. Esta información adicional se denomina _valor asociado_ y varía cada vez que usa ese caso como un valor en su código.

Se pueden definir enumeraciones de Swift para almacenar valores asociados de cualquier tipo dado, y los tipos de valor pueden ser diferentes para cada caso de la enumeración si es necesario. Las enumeraciones similares a estas se conocen como _uniones discriminadas_, _uniones etiquetadas_ o _variantes_ en otros lenguajes de programación.

Por ejemplo, suponga que un sistema de seguimiento de inventario necesita realizar un seguimiento de los productos mediante dos tipos diferentes de código de barras. Algunos productos están etiquetados con códigos de barras 1D en formato UPC, que utiliza los números del `0` to `9`. Cada código de barras tiene un dígito del sistema numérico, seguido de cinco dígitos del código del fabricante y cinco dígitos del código del producto. Estos van seguidos de un dígito de control para verificar que el código se ha escaneado correctamente:

<img
  src="/assets/images/barcode_UPC_2x.png"
  alt="Código de Barras UPC"
  width={252}
  height={120}
  className="figure-small"
/>

Otros productos son etiquetados con códigos de barras 2D en formato QR, el cual puede utilizar cualquiera de los caracteres definidos por ISO 8859-1 y los puede codificar en una cadena de 2,953 caracteres de longitud:

<img
  src="/assets/images/barcode_QR_2x.png"
  alt="Código de Barras QR"
  width={169}
  height={169}
  className="figure-small"
/>

Es conveniente que un sistema de seguimiento de inventario almacene códigos de barras UPC como una tupla de cuatro enteros y códigos de barras de códigos QR como una cadena de cualquier longitud.

En Swift, una enumeración para definir códigos de barras de productos de cualquier tipo podría verse así:

<CodeSnippet>
  {`enum CodigoDeBarras {
    case upc(Int, Int, Int, Int)
    case codigoQR(String)
}`}
</CodeSnippet>

Esto puede leerse como:

“Definir un tipo de enumeración llamada `CodigoDeBarras`, la cual puede tomar un valor `upc` con un tipo de valor asociado `(Int, Int, Int, Int)`, o un valor de  `codigoQR` con un valor asociado de tipo `String`.”

Esta definición no proporciona ningún valor `Int`o `String` real, solo define el tipo de valores asociados que las constantes y variables de `CodigoDeBarras` pueden almacenar cuando son iguales a `CodigoDeBarras.upc` o `CodigoDeBarras.codigoQR`. 

Se pueden entonces crear nuevos tipos de código de barras definiéndolo así:

<CodeSnippet>{`var productoCodigoDeBarras = CodigoDeBarras.upc(8, 85909, 51226, 3)`}</CodeSnippet>

Este ejemplo crea una variable llamada `productoCodigoDeBarras` y le asigna el valor `CodigoDeBarras.upc` con una tupla asociada con valores de (8, 85909, 51226, 3)`.

Se puede asignar al mismo producto un diferente tipo de código de barras:

 <CodeSnippet>{`productoCodigoDeBarras = .codigoQR("ABCDEFGHIJKLMNOP")`}</CodeSnippet>

Hasta ahora, el `CodigoDeBarras.upc` original y sus valores enteros se reemplazan por el nuevo `CodigoDeBarras.codigoQR` y su valor de cadena. Las constantes y variables de tipo `CodigoDeBarras` pueden almacenar un `.upc` o un `.codigoQR` (junto con sus valores asociados), pero solo pueden almacenar uno de ellos en un momento dado.

Se pueden verificar los diferentes tipos de códigos de barras utilizando una sentencia _switch_, similar al ejemplo en [Utilización de los valores de una Enumeración en una sentencia switch](#utilización-de-los-valores-de-una-enumeración-en-una-sentencia-switch). Esta vez, sin embargo, los valores asociados se extraen como parte de la declaración de cambio. Extrae cada valor asociado como una constante (con el prefijo `let`) o una variable (con el prefijo `var`) para usar dentro del cuerpo del caso de la sentencia `switch`: 

<CodeSnippet>
  {`switch productoCodigoDeBarras {
case .upc(let numberoSistema, let fabricante, let producto, let verificacion):
    print("UPC: \\(numeroSistema), \\(fabricante), \\(producto), \\(verificacion).")
case .qrCode(let codigoProducto):
    print("Código QR: \\(codigoProducto).")
}
// Imprime "Código QR: ABCDEFGHIJKLMNOP."`}
</CodeSnippet>

Si todos los valores asociados para un caso de enumeración se extraen como constantes, o si todos se extraen como variables, puede colocar una sola anotación `var` o `let` antes del nombre del caso, por razones de brevedad:

<CodeSnippet>
  {`switch productoCodigoDeBarras {
case let .upc(numeroSistema, fabricante, producto, verificacion):
    print("UPC : \\(numeroSistema), \\(fabricante), \\(producto), \\(verificacion).")
case let .qrCode(productCode):
    print("Código QR: \\(productoCodigoDeBarras).")
}
// Imprime "Código QR: ABCDEFGHIJKLMNOP."`}
</CodeSnippet>

## Valores predefinidos (_raw_)

El ejemplo de código de barras en [Valores Asociados](#valores-asociados) muestra cómo los casos de una enumeración pueden declarar que almacenan valores asociados de diferentes tipos. Como alternativa a los valores asociados, los casos de enumeración pueden incluir valores predeterminados (llamados valores _raw_), que son todos del mismo tipo.

Aquí hay un ejemplo que almacena valores ASCII sin procesar junto con casos de enumeración con nombre:

<CodeSnippet>
  {`enum CaracteresDeControlASCII: Character {
    case tabulador = "\\t"
    case avanceDeLinea = "\\n"
    case retornoDeCarro = "\\r"
}`}
</CodeSnippet>

Aquí, los valores predefinidos (_raw_) para la enumeración `CaracteresDeControlASCII` están definidos para ser de tipo `Character`, y son un conjunto de los caracteres de control ASCII más comunes. Los valores de tipo caracter `Character` están descritos en [Cadenas y caracteres](./cadenas-y-caracteres).

Los valores predefinidos pueden ser cadenas, caracteres, o cualquier tipo de dato numérico entero o flotante. Cada valor predeterminado debe ser único dentro de la declaración de la enumeración.

<Callout>
  Los valores predefinidos _no son_ lo mismo que _valores asociados_. Los valores predefinidos son un conjunto
  de valores prellenados cuando se define la enumeración en el codigo, como
  los tres caracteres ASCII del ejemplo anterior. El valor predefinido para un caso de  enumeración en particular
  es siempre el mismo. Los valores asociados se establecen cuando se crea una nueva constante
  o variable basada en los caso de la enumeración, y puede ser diferente
  cada vez que se hace.
</Callout>

## Valores Asociados de Forma Implícita

Cuando se trabaja con enumeraciones que almacenan valores sin formato de cadena o enteros, no tiene que asignarse explícitamente un valor sin formato para cada caso. Cuando no lo hace, Swift asigna automáticamente los valores por usted.

Por ejemplo, cuando se utilizan números enteros para valores brutos, el valor implícito para cada caso es uno más que el caso anterior. Si el primer caso no tiene un valor establecido, su valor es `0`.

La siguiente enumeración es un refinamiento de la enumeración anterior `Planeta`, con valores enteros sin procesar para representar el orden de cada planeta desde el sol:

<CodeSnippet>
  {`enum Planeta: Int {
    case mercurio = 1, venus, tierra, marte, jupiter, saturno, urano, neptuno
}`}
</CodeSnippet>

En el ejemplo anterior, `Planeta.mercurio` tiene un valor definido explicitamente de `1`, `Planeta.venus` tiene un valor predefinido explictamentehas de `2`, y así sucesivamente.

Cuando se utilizan cadenas para valores predefinidos, el valor implícito predeterminado para cada caso es el texto del nombre de ese caso.

La siguiente enumeración es una mejora de la enumeración anterior `PuntoCardinal`, con valores de cadena que representan el nombre de cada dirección:

<CodeSnippet>
  {`enum PuntoCardinal: String {
    case norte, sur, este, oeste
}`}
</CodeSnippet>

En el ejemplo anterior, `PuntoCardinal.sur` tiene un valor predefinido implicitamente de `"sur"`, y así sucesivamente.

Se puede acceder a los valores predefinidos de forma implícita de cada caso mediante la propieadad `rawValue`:

<CodeSnippet>
  {`let ordenTierra = Planeta.tierra.rawValue
// ordenTierra es 3\n
let  direccionAtardecer = PuntoCardinal.oeste.rawValue
// direccionAtardecer es "oeste"`}
</CodeSnippet>

### Initializing from a Raw Value

If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value's type (as a parameter called `rawValue`) and returns either an enumeration case or `nil`. You can use this initializer to try to create a new instance of the enumeration.

This example identifies Uranus from its raw value of `7`:

<CodeSnippet>
  {`let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet is of type Planet? and equals Planet.uranus`}
</CodeSnippet>

Not all possible `Int` values will find a matching planet, however. Because of this, the raw value initializer always returns an _optional_ enumeration case. In the example above, `possiblePlanet` is of type `Planet?`, or “optional `Planet`.”

<Callout>
  The raw value initializer is a failable initializer, because not every raw
  value will return an enumeration case. For more information, see [Failable
  Initializers](../referencia-del-lenguaje/declaraciones#inicializadores-falibles).
</Callout>

If you try to find a planet with a position of `11`, the optional `Planet` value returned by the raw value initializer will be `nil`:

<CodeSnippet>
  {`let positionToFind = 11\n
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print("Mostly harmless")
    default:
        print("Not a safe place for humans")
    }
} else {
    print("There isn't a planet at position \\(positionToFind)")
}
// Prints "There isn't a planet at position 11"`}
</CodeSnippet>

This example uses optional binding to try to access a planet with a raw value of `11`. The statement `if let somePlanet = Planet(rawValue: 11)` creates an optional `Planet`, and sets `somePlanet` to the value of that optional `Planet` if it can be retrieved. In this case, it isn't possible to retrieve a planet with a position of `11`, and so the `else` branch is executed instead.

## Recursive Enumerations

A _recursive enumeration_ is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases. You indicate that an enumeration case is recursive by writing `indirect` before it, which tells the compiler to insert the necessary layer of indirection.

For example, here is an enumeration that stores simple arithmetic expressions:

<CodeSnippet>
  {`enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}`}
</CodeSnippet>

You can also write `indirect` before the beginning of the enumeration to enable indirection for all of the enumeration's cases that have an associated value:

<CodeSnippet>
  {`indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}`}
</CodeSnippet>

This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions. The `addition` and `multiplication` cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions. For example, the expression `(5 + 4) * 2` has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication. Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive. The code below shows the `ArithmeticExpression` recursive enumeration being created for `(5 + 4) * 2`:

<CodeSnippet>
  {`let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))`}
</CodeSnippet>

A recursive function is a straightforward way to work with data that has a recursive structure. For example, here's a function that evaluates an arithmetic expression:

<CodeSnippet>
  {`func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}\n
print(evaluate(product))
// Prints "18"`}
</CodeSnippet>

This function evaluates a plain number by simply returning the associated value. It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.

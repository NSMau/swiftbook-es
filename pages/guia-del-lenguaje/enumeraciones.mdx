---
title: Enumeraciones
---

import CodeSnippet from '../../components/CodeSnippet.js'
import Callout from '../../components/Callout.js'

# Enumeraciones

Una _enumeración_ define un tipo común para un grupo de valores realaciondos y le permite trabajar con esos valores de forma segura utilizando tipos de datos verificados.

Si está familiarizado con lenguaje C, sabrá que las enumeraciones de C asignan nombres relacionados a un conjunto de valores enteros. Las enumeraciones en Swift son mucho más flexibles y no tienen que proporcionar un valor para cada caso de la enumeración. Si se proporciona un valor (conocido como _raw o clasificador_ ) para cada caso de enumeración, el valor puede ser una cadena, un carácter o un valor de cualquier tipo entero o de punto flotante.

Alternativamente, los casos de enumeración pueden especificar valores asociados de cualquier tipo que se almacenarán junto con cada valor de caso diferente, como lo hacen las uniones o variantes en otros idiomas. Usted puede definir un conjunto común de casos relacionados como parte de una enumeración, cada uno de los cuales tiene un conjunto diferente de valores de tipos apropiados asociados.

Las enumeraciones en Swift son tipos de primera clase en su propio derecho. Adopan muchas características tradicionalmente soportadas solamente por clases, talas como propiedades calculadas para proporcionar información adicional acerca de el valor actual de la enumeración e instancias de métodos para proporcionar funcionalidad relacionada a los valores que representa la enumeración.  Las enumeraciones también pueden definir inicializadores para proporcionar un valor de caso inicial; se pueden extender para expandir su funcionalidad más allá de la implementación original; y pueden ajustarse a los protocolos para proporcionar una funcionalidad estándar. 

Para más información de estas características, vea [Propiedades](./propiedades), [Métodos](./metodos), [Inicialización](./inicializacion), [Extensiones](./extensiones), and [Protocolos](./protocolos).

## Enumeración: Sintáxis

Puede declarar enumeraciones con la palabra reservada `enum` y poner la definición completa entre un par de llaves:

<CodeSnippet>
  {`enum AlgunaEnumeration {
    // la definición de la enumeración va aquí
}`}
</CodeSnippet>

Aquí está un ejemplo para los cuatro puntos principales de una brújula:

<CodeSnippet>
  {`enum PuntoCardinal {
    case norte
    case sur
    case este
    case oeste
}`}
</CodeSnippet>

Los valores definidos en una enumeración (tales como `norte`, `sur`, `este`, y `oeste`) son sus _casos de enumeración_. Se usa la palabra reservada  `case` para definir un nuevo caso de la enumeración.

<Callout>
  En Swift los casos de enumeración no tienen un valor entero asignado por default, a diferencia
  de lenguajes como C y Objective-C. En el ejemplo anterior de  `PuntoCardinal`,
  `norte`, `sur`, `este`, y `oeste` no corresponden a los valores `0`, `1`, `2`, y
  `3`. Por el contrario, los diferentes casos de la enumeración tienen su propio valor,
  con un explicitamente definido en  `PuntoCardinal`.
</Callout>

Se pueden declarar múlltiples casos en una sola línea, separados por comas:

<CodeSnippet>
  {`enum Planeta {
    case mercurio, venus, tierra, marte, jupiter, saturno, urano, neptuno
}`}
</CodeSnippet>

Cada declaración de una enumeración define un nuevo tipo. Como los otros tipos en Swift, sus nombre (tales como `PuntoCardinal` and `Planeta`) inician con una letra mayúscula. Dé a los tipos de enumeración nombres singulares en lugar de plurales, para que se lean como evidentes:


<CodeSnippet>{`var avanzarEnDireccion = PuntoCardinal.norte`}</CodeSnippet>

El tipo de  `avanzarEnDireccion` se infiere cuando es inicializado con uno de los posibles valores de `PuntoCardinal`. Una vez que  `avanzarEnDireccion` es declarado como un  `PuntoCardinal`, se puede cambiar a un diferente valor de `PuntoCardinal` de forma corte usando un punto la sintaxis es:

<CodeSnippet>{`avanzarEnDireccion = .este`}</CodeSnippet>

El tipo de `avanzarEnDireccion` ya se conoce, por lo tanto se puede asiganar el otro tipo cuando se asigna su valor. Esto hace que el código sea muy legible cuando se trabaja con valores de enumeración escritos explícitamente.

 ## Utilización de loa valores de una Enumeración en una sentencia Switch

Se puede busca la coincidencia de los valores individuales de una enumeración con una sentencia`switch:

<CodeSnippet>
  {`avanzarEnDireccion = .sur\n
switch avanzarEnDireccion {
case .norte:
    print("Muchos planetas tienen un norte")
case .sur:
    print("Mira los pingüinos")
case .este:
    print("Donde nace el sol")
case .oeste:
    print("donde el cielo es azul")
}
// Prints "Mira los pingüinos"`}
</CodeSnippet>

El código se puede leer como:

“Considerando del valor de `avanzarEnDireccion`. En caso de que sea `.norte`, imprime `"Muchos planetas tienen un norte"`. En caso de que sea igula a `.sur`, imprime `"Mira los pingüinos"`.”

…y así sucesivamente.

Como se describe en [Flujos de Control](./flujo-de-control), una sentencia `switch`  debe ser exhaustiva al considerar los casos de una enumeración. Si se omite el caso para `.oeste`,  este código no compila, porque no considera la lista completa de casos de PuntoCardinal. Requerir exhaustividad garantiza que los casos de enumeración no se omitan accidentalmente.

Cuando no sea apropiado proporcionar un `case` para cada caso de la enumeración, se puede proporcionar un caso `default` para cubrir cualquier caso que no se use explícitamente:

<CodeSnippet>
  {`let algunPlaneta = Planeta.tierra\n
switch algunPlaneta {
case .tierra:
    print("Mayoritariamente inofensivo")
default:
    print("No es un lugar seguro para los humanos")
}
// Prints "Mayoritariamente inofensivo"`}
</CodeSnippet>

## Iterating over Enumeration Cases

For some enumerations, it's useful to have a collection of all of that enumeration's cases. You enable this by writing `: CaseIterable` after the enumeration's name. Swift exposes a collection of all the cases as an `allCases` property of the enumeration type. Here's an example:

<CodeSnippet>
  {`enum Beverage: CaseIterable {
    case coffee, tea, juice
}\n
let numberOfChoices = Beverage.allCases.count
print("\\(numberOfChoices) beverages available")
// Prints "3 beverages available"`}
</CodeSnippet>

In the example above, you write `Beverage.allCases` to access a collection that contains all of the cases of the `Beverage` enumeration. You can use `allCases` like any other collection—the collection's elements are instances of the enumeration type, so in this case they're `Beverage` values. The example above counts how many cases there are, and the example below uses a `for-in` loop to iterate over all the cases.

<CodeSnippet>
  {`for beverage in Beverage.allCases {
    print(beverage)
}
// coffee
// tea
// juice`}
</CodeSnippet>

The syntax used in the examples above marks the enumeration as conforming to the [CaseIterable](https://developer.apple.com/documentation/swift/caseiterable) protocol. For information about protocols, see [Protocols](./protocolos).

## Associated Values

The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right. You can set a constant or variable to `Planet.earth`, and check for this value later. However, it's sometimes useful to be able to store values of other types alongside these case values. This additional information is called an _associated value_, and it varies each time you use that case as a value in your code.

You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed. Enumerations similar to these are known as _discriminated unions_, _tagged unions_, or _variants_ in other programming languages.

For example, suppose an inventory tracking system needs to track products by two different types of barcode. Some products are labeled with 1D barcodes in UPC format, which uses the numbers `0` to `9`. Each barcode has a number system digit, followed by five manufacturer code digits and five product code digits. These are followed by a check digit to verify that the code has been scanned correctly:

<img
  src="/assets/images/barcode_UPC_2x.png"
  alt="UPC Barcode"
  width={252}
  height={120}
  className="figure-small"
/>

Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:

<img
  src="/assets/images/barcode_QR_2x.png"
  alt="QR Barcode"
  width={169}
  height={169}
  className="figure-small"
/>

It's convenient for an inventory tracking system to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.

In Swift, an enumeration to define product barcodes of either type might look like this:

<CodeSnippet>
  {`enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}`}
</CodeSnippet>

This can be read as:

“Define an enumeration type called `Barcode`, which can take either a value of `upc` with an associated value of type `(Int, Int, Int, Int)`, or a value of `qrCode` with an associated value of type `String`.”

This definition doesn't provide any actual `Int` or `String` values—it just defines the _type_ of associated values that `Barcode` constants and variables can store when they're equal to `Barcode.upc` or `Barcode.qrCode`.

You can then create new barcodes using either type:

<CodeSnippet>{`var productBarcode = Barcode.upc(8, 85909, 51226, 3)`}</CodeSnippet>

This example creates a new variable called `productBarcode` and assigns it a value of `Barcode.upc` with an associated tuple value of `(8, 85909, 51226, 3)`.

You can assign the same product a different type of barcode:

<CodeSnippet>{`productBarcode = .qrCode("ABCDEFGHIJKLMNOP")`}</CodeSnippet>

At this point, the original `Barcode.upc` and its integer values are replaced by the new `Barcode.qrCode` and its string value. Constants and variables of type `Barcode` can store either a `.upc` or a `.qrCode` (together with their associated values), but they can store only one of them at any given time.

You can check the different barcode types using a switch statement, similar to the example in [Matching Enumeration Values with a `switch` Statement](#matching-enumeration-values-with-a-switch-statement). This time, however, the associated values are extracted as part of the switch statement. You extract each associated value as a constant (with the `let` prefix) or a variable (with the `var` prefix) for use within the `switch` case's body:

<CodeSnippet>
  {`switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print("UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).")
case .qrCode(let productCode):
    print("QR code: \\(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."`}
</CodeSnippet>

If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single `var` or `let` annotation before the case name, for brevity:

<CodeSnippet>
  {`switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print("UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).")
case let .qrCode(productCode):
    print("QR code: \\(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."`}
</CodeSnippet>

## Raw Values

The barcode example in [Associated Values](#associated-values) shows how cases of an enumeration can declare that they store associated values of different types. As an alternative to associated values, enumeration cases can come prepopulated with default values (called _raw values_), which are all of the same type.

Here's an example that stores raw ASCII values alongside named enumeration cases:

<CodeSnippet>
  {`enum ASCIIControlCharacter: Character {
    case tab = "\\t"
    case lineFeed = "\\n"
    case carriageReturn = "\\r"
}`}
</CodeSnippet>

Here, the raw values for an enumeration called `ASCIIControlCharacter` are defined to be of type `Character`, and are set to some of the more common ASCII control characters. `Character` values are described in [Strings and Characters](./cadenas-y-caracteres).

Raw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration.

<Callout>
  Raw values are _not_ the same as associated values. Raw values are set to
  prepopulated values when you first define the enumeration in your code, like
  the three ASCII codes above. The raw value for a particular enumeration case
  is always the same. Associated values are set when you create a new constant
  or variable based on one of the enumeration's cases, and can be different each
  time you do so.
</Callout>

## Implicitly Assigned Raw Values

When you're working with enumerations that store integer or string raw values, you don't have to explicitly assign a raw value for each case. When you don't, Swift automatically assigns the values for you.

For example, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn't have a value set, its value is `0`.

The enumeration below is a refinement of the earlier `Planet` enumeration, with integer raw values to represent each planet's order from the sun:

<CodeSnippet>
  {`enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}`}
</CodeSnippet>

In the example above, `Planet.mercury` has an explicit raw value of `1`, `Planet.venus` has an implicit raw value of `2`, and so on.

When strings are used for raw values, the implicit value for each case is the text of that case's name.

The enumeration below is a refinement of the earlier `PuntoCardinal` enumeration, with string raw values to represent each direction's name:

<CodeSnippet>
  {`enum PuntoCardinal: String {
    case north, south, east, west
}`}
</CodeSnippet>

In the example above, `PuntoCardinal.south` has an implicit raw value of `"south"`, and so on.

You access the raw value of an enumeration case with its `rawValue` property:

<CodeSnippet>
  {`let earthsOrder = Planet.earth.rawValue
// earthsOrder is 3\n
let sunsetDirection = PuntoCardinal.west.rawValue
// sunsetDirection is "west"`}
</CodeSnippet>

### Initializing from a Raw Value

If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value's type (as a parameter called `rawValue`) and returns either an enumeration case or `nil`. You can use this initializer to try to create a new instance of the enumeration.

This example identifies Uranus from its raw value of `7`:

<CodeSnippet>
  {`let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet is of type Planet? and equals Planet.uranus`}
</CodeSnippet>

Not all possible `Int` values will find a matching planet, however. Because of this, the raw value initializer always returns an _optional_ enumeration case. In the example above, `possiblePlanet` is of type `Planet?`, or “optional `Planet`.”

<Callout>
  The raw value initializer is a failable initializer, because not every raw
  value will return an enumeration case. For more information, see [Failable
  Initializers](../referencia-del-lenguaje/declaraciones#inicializadores-falibles).
</Callout>

If you try to find a planet with a position of `11`, the optional `Planet` value returned by the raw value initializer will be `nil`:

<CodeSnippet>
  {`let positionToFind = 11\n
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print("Mostly harmless")
    default:
        print("Not a safe place for humans")
    }
} else {
    print("There isn't a planet at position \\(positionToFind)")
}
// Prints "There isn't a planet at position 11"`}
</CodeSnippet>

This example uses optional binding to try to access a planet with a raw value of `11`. The statement `if let somePlanet = Planet(rawValue: 11)` creates an optional `Planet`, and sets `somePlanet` to the value of that optional `Planet` if it can be retrieved. In this case, it isn't possible to retrieve a planet with a position of `11`, and so the `else` branch is executed instead.

## Recursive Enumerations

A _recursive enumeration_ is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases. You indicate that an enumeration case is recursive by writing `indirect` before it, which tells the compiler to insert the necessary layer of indirection.

For example, here is an enumeration that stores simple arithmetic expressions:

<CodeSnippet>
  {`enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}`}
</CodeSnippet>

You can also write `indirect` before the beginning of the enumeration to enable indirection for all of the enumeration's cases that have an associated value:

<CodeSnippet>
  {`indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}`}
</CodeSnippet>

This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions. The `addition` and `multiplication` cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions. For example, the expression `(5 + 4) * 2` has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication. Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive. The code below shows the `ArithmeticExpression` recursive enumeration being created for `(5 + 4) * 2`:

<CodeSnippet>
  {`let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))`}
</CodeSnippet>

A recursive function is a straightforward way to work with data that has a recursive structure. For example, here's a function that evaluates an arithmetic expression:

<CodeSnippet>
  {`func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}\n
print(evaluate(product))
// Prints "18"`}
</CodeSnippet>

This function evaluates a plain number by simply returning the associated value. It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.

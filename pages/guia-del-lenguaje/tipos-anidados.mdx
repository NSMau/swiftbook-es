---
title: Tipos Anidados
---

import Hero from '@components/Hero'

<Hero>
  # Tipos Anidados

Define tipos dentro del ámbito de otro tipo.

</Hero>

Las enumeraciones se suelen crear para apoyar la funcionalidad de una clase o estructura específica. De forma similar, puede ser útil definir clases y estructuras utilitarias únicamente para su uso en el contexto de un tipo más complejo. Para conseguir esto, Swift permite definir _tipos anidados_, con los que se pueden anidar enumeraciones, clases y estructuras de apoyo dentro de la definición del propio tipo.

Para anidar un tipo dentro de otro tipo, escribe la definición dentro de sus llaves exteriores. Los tipos se pueden anidar en tantos niveles como se quiera.

## Tipos Anidados en Acción

El ejemplo siguiente define la estructura llamada `NaipeBlackjack`, que representa un naipe como los usados en el juego de Blackjack. La estructura `NaipeBlackjack` contiene dos tipos anidados de enumeración llamados `Palo` y `Rango`.

En el juego de Blackjack, los Ases tienen valor uno u once. Esta característica está representada por la estructura llamada `Valores`, que está anidada dentro de la enumeración `Rango`:

```swift showLineNumbers
struct NaipeBlackjack {

    // enumeración anidada Palo
    enum Palo: Character {
        case picas = "♠", corazones = "♡", diamantes = "♢", treboles = "♣"
    }

    // enumeración anidada Rango
    enum Rango: Int {
        case dos = 2, tres, cuatro, cinco, seis, siete, ocho, nueve, diez
        case sota, dama, rey, _as

        // estructura anidada Valores
        struct Valores {
            let primero: Int, segundo: Int?
        }

        var valores: Valores {
            switch self {
            case ._as:
                return Valores(primero: 1, segundo: 11)
            case .sota, .dama, .rey:
                return Valores(primero: 10, segundo: nil)
            default:
                return Valores(primero: self.rawValue, segundo: nil)
            }
        }
    }

    // Propiedades y métodos de NaipeBlackjack
    let rango: Rango, palo: Palo

    var descripcion: String {
        var resultado = "el palo es \(palo.rawValue),"
        resultado += " el valor es \(rango.valores.primero)"

        if let segundo = rango.valores.segundo {
            resultado += " o \(segundo)"
        }

        return resultado
    }
}
```

La enumeración `Palo` describe los cuatro palos habituales de los naipes, junto con
un valor `Character` en bruto para representar su símbolo.

La enumeración `Rango` describe los trece posibles valores de rango de los naipes, junto con un valor `Int` en bruto para representar su valor nominal. (Este valor `Int` en bruto no se usa para los naipes Sota, Dama, Rey y As.)

Como se menciona arriba, la enumeración Rango describe una estructura anidada propia, llamada `Valores`. Esta estructura encapsula el hecho de que la mayoría de los naipes tienen un único valor, mientras que el naipe As tiene dos valores. La estructura `Valores` describe dos propiedades para representar esto:

- `primero`, de tipo `Int`
- `segundo`, de tipo `Int?`, o "`Int` opcional"

Rango también describe una propiedad calculada, `valores`, que devuelve una instancia de la estructura `Valores`. Esta propiedad calculada analiza el rango del naipe y crea una nueva instancia de `Valores` con el valor adecuado para su rango. Usa valores especiales para `sota`, `dama`, `rey` y `_as`. Para los naipes numéricos, usa el valor `Int` en bruto del rango.

La estructura `NaipeBlackjack` tiene dos propiedades: `rango` y `palo`. También tiene una propiedad calculada llamada `descripcion`, que usa los valores almacenados en `rango` y `palo` para componer una descripción del nomber y valor del naipe. La propiedad `descripcion` usa vinculación opcional para comprobar si hay un segundo valor que mostrar y, si lo hay, añade detalles de descripción adicionales para ese segundo valor.

Debido a que `NaipeBlackjack` es una estructura sin inicializadores a medida, tiene un inicializador implícito a nivel de miembro [Inicializadores de Miembro para Tipos Estructura](./inicializacion#inicializadores-de-miembro-para-tipos-estructura). Se puede usar este inicializador para inicializar una nueva constante llamada `elAsDePicas`

```swift showLineNumbers
let elAsDePicas = NaipeBlackjack(rango: ._as, palo: .picas)

print("elAsDePicas: \(elAsDePicas.descripcion)")
// Imprime "elAsDePicas: el palo es ♠, el valor es 1 o 11"
```

Aunque `Rango` y `Palo` están anidadas dentro de `NaipeBlackjack`, su tipo puede ser deducido del contexto, y por tanto la inicialización de esta instancia puede hacer referencia a los casos de la enumeración usando únicamente los nombres de sus casos (`.as` y `.picas`). En el ejemplo anterior, la propiedad `descripcion` informa de que el As de Picas tiene el valor `1` o `11`.

## Haciendo referencia a Tipos Anidados

Para usar un tipo anidado fuera de su contexto de definición, añade como prefijo a su nombre el nombre del tipo en el que está anidado:

```swift showLineNumbers
let simboloDeCorazones = NaipeBlackjack.Palo.corazones.rawValue
// simboloDeCorazones es "♡"
```

Para el ejemplo anterior, esto permite mantener los nombres `Palo`, `Rango` y `Valores` deliberadamente cortos, porque sus nombres están naturalmente cualificados por el contexto en el que se definen.

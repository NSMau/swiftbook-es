---
title: Desinicialización
---

import Hero from '@components/Hero'

<Hero>
  # Desinicialización

{/* Release resources that require custom cleanup. */}
Libera recursos que requieren una limpieza a medida.

</Hero>

{/* A _deinitializer_ is called immediately before a class instance is deallocated. You write deinitializers with the `deinit` keyword, similar to how initializers are written with the `init` keyword. Deinitializers are only available on class types. */}
Un _desinicializador_ se ejecuta justo antes de la reasignación de una instancia de clase. Los desinicializadores se describen con la palabra clave `deinit`, de las misma forma que los inicializadores se describen con la palabra clave `init`. Los desinicializadores sólo están disponibles en las clases.

{/* ## How Desinicialización Works */}

## Cómo funciona la desinicialización

{/* Swift automatically deallocates your instances when they’re no longer needed, to free up resources. Swift handles the memory management of instances through _automatic reference counting (ARC)_, as described in [Automatic Reference Counting](./automatic-reference-counting). Typically you don’t need to perform manual cleanup when your instances are deallocated. However, when you are working with your own resources, you might need to perform some additional cleanup yourself. For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated. */}
Swift reasigna automáticamente tus instancias cuando dejan de ser necesarias, para liberar recursos. Swift maneja la gestión de memoria de las instancias mediante _conteo automático de referencias (ARC)_, como se describe en [Conteo automático de referencias](./conteo-automatico-de-referencias). Normalmente, no hay que hacer limpieza manualmente cuando las instancias son reasignadas. Sin embargo, cuando trabajas con tus propios recursos, es posible que tengas que hacer algo de limpieza adicional. Por ejemplo, si creas una clase personalizada para abrir un archivo y escribir información en él, es posible que tengas que cerrar el archivo antes de la reasignación de la instancia de clase.

{/* Class definitions can have at most one deinitializer per class. The deinitializer doesn’t take any parameters and is written without parentheses: */}
Las definiciones de clase sólo pueden tener un desinicializador. El desinicializador no recibe ningún parámetro y se escribe sin paréntesis:

```swift showLineNumbers
deinit {
    // Realiza la desinicialización
}
```

{/* Deinitializers are called automatically, just before instance deallocation takes place. You aren’t allowed to call a deinitializer yourself. Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation. Superclass deinitializers are always called, even if a subclass doesn’t provide its own deinitializer. */}
Los desinicializadores se llaman automáticamente, justo antes de la reasignación de la instancia. No está permitido llamar directamente a un desinicializador. Las subclases heredan el desinicializador de su superclase, que se ejecuta automáticamente al final de la implementación del desinicializador de la subclase. Los desinicializadores de una superclase siempre se ejecutan, incluso aunque la subclase no tenga un desinicializador propio.

{/* Because an instance isn’t deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it’s called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed). */}
Debido a que una instancia no se reasigna hasta la ejecución de su desinicializador, el desinicializador tiene acceso a todas las propiedades de la instancia en la que es llamado y puede modificar su comportamiento en función de esas propiedades (por ejemplo, consultando el nombre del archivo a cerrar).

{/* ## Deinitializers in Action */}

## Desinicializadores en acción

{/* Here’s an example of a deinitializer in action. This example defines two new types, `Banco` and `Jugador`, for a simple game. The `Banco` class manages a made-up currency, which can never have more than 10,000 coins in circulation. There can only ever be one `Banco` in the game, and so the `Banco` is implemented as a class with type properties and methods to store and manage its current state: */}
El siguiente ejemplo ilustra un inicializador en acción. Este ejemplo define dos nuevos tipos para un juego sencillo: `Banco` y `Jugador`. La clase `Banco` gestiona una divisa inventada que nunca puede tener más de 10.000 monedas en circulación. Sólo puede haber un `Banco` en el juego, definido como una clase con propiedades y métodos para almacenar y gestionar su estado actual:

```swift showLineNumbers
class Banco {
    static var monedasEnBanco = 10_000

    static func distribuir(monedas numeroDeMonedasSolicitadas: Int) -> Int {
        let numeroDeMonedasParaVender = min(numeroDeMonedasSolicitadas, monedasEnBanco)

        monedasEnBanco -= numeroDeMonedasParaVender

        return numeroDeMonedasParaVender
    }

    static func recibir(monedas: Int) {
        monedasEnBanco += monedas
    }
}
```

{/* `Banco` keeps track of the current number of coins it holds with its `monedasEnBanco` property. It also offers two methods — `distribuir(coins:)` and `recibir(coins:)` — to handle the distribution and collection of coins. */}
`Banco` lleva la cuenta de la cantidad de monedas que tiene mediante la propiedad `monedasEnBanco`. También tiene dos métodos (`distribuir(monedas:)` y `recibir(monedas:)`) para manejar la distribución y recolección de monedas.

{/* The `distribuir(coins:)` method checks that there are enough coins in the bank before distributing them. If there aren’t enough coins, Banco returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank). It returns an integer value to indicate the actual number of coins that were provided. */}
El método `distribuir(monedas:)` comprueba que hay suficientes monedas en el banco antes de distribuirlas. Si no hay monedas suficientes, `Banco` devuelve menos monedas que las solicitadas (y devuelve cero si no quedan monedas en el banco). Devuelve un número entero para indicar la cantidad de monedas que han sido proporcionadas.

{/* The `recibir(coins:)` method simply adds the received number of coins back into the bank’s coin store. */}
El método `recibir(monedas:)` simplemente añade la cantidad de monedas recibidas al conjunto de monedas del banco.

{/* The `Jugador` class describes a player in the game. Each player has a certain number of coins stored in their purse at any time. This is represented by the player’s `coinsInPurse` property: */}
La clase `Jugador` describe al participante del juego. En cualquier momento, cada jugador tiene una cierta cantidad de monedas almacenadas en su monedero. Esto está representado por la propiedad del jugador llamada `monedasEnMonedero`:

```swift showLineNumbers
class Jugador {
    var monedasEnMonedero: Int

    init(monedas: Int) {
        monedasEnMonedero = Banco.distribuir(monedas: monedas)
    }

    func ganar(monedas: Int) {
        monedasEnMonedero += Banco.distribuir(monedas: monedas)
    }

    deinit {
        Banco.recibir(monedas: monedasEnMonedero)
    }
}
```

{/* Each `Jugador` instance is initialized with a starting allowance of a specified number of coins from the bank during initialization, although a `Jugador` instance may receive fewer than that number if not enough coins are available. */}
Cada instancia de `Jugador` se inicializa con una asignación inicial de monedas del banco, aunque una instancia de `Jugador` puede recibir una cantidad menor si no hay suficientes monedas disponibles.

{/* The `Jugador` class defines a `win(coins:)` method, which retrieves a certain number of coins from the bank and adds them to the player’s purse. The `Jugador` class also implements a deinitializer, which is called just before a `Jugador` instance is deallocated. Here, the deinitializer simply returns all of the player’s coins to the bank: */}
La clase `Jugador` define el método `ganar(monedas:)`, que recibe una cantidad de monedas del banco y las añade al monedero del jugador. La clase `Jugador` también tiene un desinicializador, que se ejecuta justo antes de la reasignación de la instancia de `Jugador`. Aquí el desinicializador simplemente devuelve al banco todas las monedas del jugador:

```swift showLineNumbers
var jugadorUno: Jugador? = Jugador(monedas: 100)

print("Un nuevo jugador se ha unido a la partida con \(jugadorUno!.monedasEnMonedero) monedas")
// Imprime "Un nuevo jugador se ha unido a la partida con 100 monedas"
print("Hay ahora \(Banco.monedasEnBanco) monedas en el banco")
// Imprime "Hay ahora 9900 monedas en el banco"
```

{/* A new `Jugador` instance is created, with a request for 100 coins if they’re available. This `Jugador` instance is stored in an optional `Jugador` variable called `playerOne`. An optional variable is used here, because players can leave the game at any point. The optional lets you track whether there’s currently a player in the game. */}
Se crea una nueva instancia de `Jugador` con una petición de 100 monedas, si están disponibles. Esta instancia de `Jugador` se almacena en una variable opcional `Jugador` llamada `jugadorUno`. Se usa una variable opcional porque los jugadores pueden abandonar el juego en cualquier momento. La variable opcional permite saber si hay jugadores en el juego.

{/* Because `playerOne` is an optional, it’s qualified with an exclamation point (`!`) when its `coinsInPurse` property is accessed to print its default number of coins, and whenever its `win(coins:)` method is called: */}
Debido a que `jugadorUno` es un opcional, se califica con un signo de exclamación (`!`) cuando se accede a su propiedad `monedasEnMonedero` para imprimir la cantidad de monedas por defecto, y cuando se ejecuta su método `ganar(monedas:)`:

```swift showLineNumbers
jugadorUno!.ganar(monedas: 2_000)

print("JugadorUno ha ganado 2000 monedas y ahora tiene \(jugadorUno!.monedasEnMonedero) monedas")
// Imprime "JugadorUno ha ganado 2000 monedas y ahora tiene 2100 monedas"
print("El banco ahora sólo tiene \(Banco.monedasEnBanco) monedas")
// Imprime "El banco ahora sólo tiene 7900 monedas"
```

{/* Here, the player has won 2,000 coins. The player’s purse now contains 2,100 coins, and the bank has only 7,900 coins left. */}
Aquí el jugador ha ganado 2.000 monedas. El monedero del jugador ahora contiene 2.100 monedas y el banco sólo tiene 7.900 monedas.

```swift showLineNumbers
jugadorUno = nil

print("JugadorUno ha abandonado el juego")
// Imprime "JugadorUno ha abandonado el juego"
print("El banco ahora tiene \(Banco.monedasEnBanco) monedas")
// Imprime "El banco ahora tiene 10000 monedas"
```

{/* The player has now left the game. This is indicated by setting the optional `playerOne` variable to `nil`, meaning “no Jugador instance.” At the point that this happens, the `playerOne` variable’s reference to the `Jugador` instance is broken. No other properties or variables are still referring to the `Jugador` instance, and so it’s deallocated in order to free up its memory. Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank. */}
Ahora el jugador ha abandonado el juego. Esto se indica definiendo la variable opcional `jugadorUno` como `nil`, lo que quiere decir que ya no es una instancia de `Jugador`. Cuando esto ocurre, la referencia a la instancia de jugador de la variable `jugadorUno` está rota. Ninguna otra propiedad o variable hace referencia a la instancia de `Jugador` y, por tanto, se reasigna para liberar su espacio de memoria. Justo antes de que esto suceda, su desinicializador se ejecuta automáticamente y sus monedas vuelven al banco.

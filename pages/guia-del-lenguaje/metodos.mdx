---
title: Métodos
---

import CodeSnippet from '../../components/CodeSnippet.js'
import Callout from '../../components/Callout.js'

# Métodos

Los _Métodos_ son funciones asociadas con un tipo particular. Las clases, estructuras y enumeraciones pueden definir métodos de instancias, los cuales encapsulan tareas y funcionalidades específicas para trabajar con una instancia de un tipo dado. Las clases, estructuras y enumeraciones también pueden definir métodos de tipo, los cuales se asocian con el propio tipo. Los métodos de tipo son similares a los métodos de clase en Objective-C.

El hecho de que las estructuras y enumeraciones puedan definir métodos en Swift es la mayor diferencia desde C y Objective-C. En Objective-C, las clases son los únicos tipos que pueden definir métodos. En Swift, puedes elegir si definir una clase, estructura o enumeración, y todavía disponer de la flexibilidad para definir métodos en el tipo que has creado.

## Métodos de instancia

Los _Métodos de instancia_ son funciones que pertenecen a las instancias de una clase, estructura o enumeración en particular. Soportan la funcionalidad de dichas instancias, tanto proporcionando formas de acceder y modificar las propiedades de la instancia, como proporcionando funcionalidad relacionada con el propósito de la instancia. Los métodos de instancia tienen exactamente la misma sintaxis que las funciones, como se describe en [Funciones](./funciones).

Un método de instancia se escribe dentro de las llaves de apertura y cierre del tipo que lo contiene. Un método de instancia tiene acceso implícito a todos los métodos de instancias y propiedades de ese tipo. Un método de instancia puede ser llamado únicamente en una instancia específica del tipo al que pertenece. No puede ser llamado de forma aislada sin una instancia existente.

<CodeSnippet>
  {`class Contador {
    var contador = 0\n
    func incrementar() {
        contador += 1
    }\n
    func incrementar(en cantidad: Int) {
        contador += cantidad
    }\n
    func restablecer() {
        contador = 0
    }
}`}
</CodeSnippet>

La clase `Contador` define tres métodos de instancia:

- `incrementar()` incremente el contador en `1`.
- `incrementar(en: Int)` incrementa el contador en una cantidad entera especificada.
- `restablecer()` restablece el contador a cero.

La clase `Contador` también declara una propiedad variable, `contador`, para mantener el registro del valor actual del contador.

Los métodos de instancia se llaman con la misma sintaxis de puntuación que las propiedades:

<CodeSnippet>
  {`let contador = Contador()
// el valor inicial de contador es 0\n
contador.incrementar()
// el valor de contador ahora es 1
contador.incrementar(en: 5)
// el valor de contador ahora es 6
contador.restablecer()
// el valor de contador ahora es 0`}
</CodeSnippet>

Los parámetros de función pueden tener tanto un nombre (para usar en el cuerpo de la función) como una etiqueta de argumento (para usar cuando se llama a la función), como se describe en [Etiquetas de argumentos y nombres de parámetros de funciones](./funciones#etiquetas-de-argumentos-de-funciones-y-nombres-de-parametros). Ocurre igual con los parámetros de método, ya que los métodos son tan solo funciones asociadas con un tipo.

### La Propiedad `self`

Todas las instancias de tipo tienen de forma implícita una propiedad llamada `self`, que es exactamente equivalente a la propia instancia. Utiliza la propiedad `self` para referirte a la instancia actual dentro de sus propios métodos de instancia.

El método `incrementar()` del ejemplo de más arriba, se podría haber escrito así:

<CodeSnippet>
  {`func incrementar() {
    self.contador += 1
}`}
</CodeSnippet>

En la práctica, no necesitas escribir `self` a menudo en tu código. Si no escribes explícitamente `self`, Swift asume que te estás refiriendo a una propiedad o método de la actual instancia siempre y cuando uses un nombre de propiedad o método conocido dentro del método. Esta presunción está demostrada por el uso de `contador` (más que por `self.contador`) dentro de los tres métodos de instancia de `Contador`.

La principal excepción a esta regla ocurre cuando un nombre de parámetro para un método de instancia tiene el mismo nombre que la propiedad de esa instancia. En esta situación, el nombre del parámetro tiene preferencia, y se hace necesario referirse a la propiedad de una forma más clara. Utiliza la propiedad `self` para distinguir entre el nombre del parámetro y el nombre de la propiedad.

Aquí, `self`diferencia entre un parámetro de método llamado `x` y una propiedad de instancia también llamada `x`: 

<CodeSnippet>
  {`struct Punto {
    var x = 0.0, y = 0.0\n
    func estaALaDerechaDe(x: Double) -> Bool {
        return self.x > x
    }
}\n
let algunPunto = Punto(x: 4.0, y: 5.0)\n
if algunPunto.estaALaDerechaDe(x: 1.0) {
    print("Este punto está a la derecha de la línea donde x == 1.0")
}
// Imprime "Este punto está a la derecha de la línea donde x == 1.0"`}
</CodeSnippet>

Sin el prefijo `self`, Swift asumiría que ambos usos de `x` se refieren al parámetro de método llamado `x`.

## Modificando Tipos por valor desde dentro de Métodos de instancia

Las estructuras y enumeraciones son _tipos por valor_. Por defecto, las propiedades de un tipo por valor no pueden ser modificadas desde dentro de sus métodos de instancia.

Sin embargo, si necesitas modificar las propiedades de tu estructura o enumeración dentro de un método particular, puedes optar por _mutar_ el comportamiento de ese método. El método puede entonces mutar (es decir, cambiar) sus propiedades desde dentro del método, y cualquier cambio que hace se escribe de nuevo a la estructura original cuando el método finalice. El método puede también asignar una instancia completamente nueva a su propiedad implícita `self`, y esta nueva instancia reemplazará la existente cuando el método finalice.

Puedes optar por este comportamiento situando la palabra clave `mutating` antes de la palabra clave `func` para ese método:

<CodeSnippet>
  {`struct Punto {
    var x = 0.0, y = 0.0\n
    mutating func moverA(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}\n
var algunPunto = Punto(x: 1.0, y: 1.0)\n
algunPunto.moverA(x: 2.0, y: 3.0)\n
print("El punto está ahora en (\\(algunPunto.x), \\(algunPunto.y))")
// Imprime "El punto está ahora en (3.0, 4.0)"`}
</CodeSnippet>

La estructura anterior `Punto` define un método mutable `moverA(x:y:)`, que mueve una instancia de `Punto` en una cierta cantidad. En lugar de devolver un nuevo punto, este método modifica el punto en el cual es llamado. La palabra clave `mutating` se añade a su definición para permitirle modificar sus propiedades.

Fíjate que no puedes llamar un método mutable en un tipo estructura constante, porque sus propiedades no pueden ser cambiadas, aunque sean propiedades variables, como se describe en [Propiedades almacenadas de instancias de estructuras constantes]

<CodeSnippet>
  {`let puntoFijo = Punto(x: 3.0, y: 3.0)\n
puntoFijo.moverA(x: 2.0, y: 3.0)
// esto devolverá un error`}
</CodeSnippet>

### Asignando a `self` dentro de un método mutable

Los métodos mutables pueden asignar toda una nueva instancia a la propiedad implícita `self`. El ejemplo `Punto` mostrado más arriba, podría haber sido en su lugar escrito de la siguiente forma:

<CodeSnippet>
  {`struct Punto {
    var x = 0.0, y = 0.0\n
    mutating func moverA(x deltaX: Double, y deltaY: Double) {
        self = Punto(x: x + deltaX, y: y + deltaY)
    }
}`}
</CodeSnippet>

Esta versión del método mutable `moverA(x:y:)` crea una nueva estructura cuyos valores `x` e `y` son establecidos a la localización de destino. El resultado final de llamar a esta versión alternativa del método será exactamente la misma que llamar a la versión anterior.

Los métodos mutables para enumeraciones pueden establecer el parámetro implícito `self` para ser un caso diferente desde la misma enumeración:

<CodeSnippet>
  {`enum SwitchTriEstado {
    case apagada, baja, alta\n
    mutating func siguiente() {
        switch self {
        case .apagada:
            self = .baja
        case .baja:
            self = .alta
        case .alta:
            self = .baja
        }
    }
}\n
var luzDelHorno = SwitchTriEstado.baja\n
luzDelHorno.siguiente()
// luzDelHorno ahora es igual a .alta
luzDelHorno.siguiente()
// luzDelHorno ahora es igual a .apagada`}
</CodeSnippet>

Este ejemplo define una enumeración para un swift de tres estados. El switch pasa por los tres diferentes estados de encendido (`apagada`, `baja`, y `alta`) siempre que el método `next()` es llamado. 
 

## Métodos de tipo

Los métodos de instancia, como se describe más arriba, son métodos que llamas en una instancia de un tipo particular. También puedes definir métodos que son llamados en el propio tipo. Estos tipos de métodos se llaman _métodos de tipo_. Indica los métodos de tipo escribiendo la palabra clave `static` antes de la palabra clave `func`. Las clases pueden usar en su lugar la palabra clave `class`, para permitir a subclases sobrescribir la implementación de ese método de la superclase.

<Callout type="note">
  En Objective-C, puedes definir métodos de tipo nivel solo para las clases
  de Objective-C. En Swift, puedes definir métodos de tipo nivel para todas las clases,
  estructuras, y enumeraciones. Cada método de tipo está explícitamente en el ámbito
  del tipo que lo soporta.
</Callout>

Los métodos de tipo se llaman con la sintaxis de puntación, como los métodos de instancia. Sin embargo, llama a los métodos de tipos en el tipo, no en una instancia de ese tipo. Aquí puedes ver como llamar a un método de tipo en una clase llamada `AlgunaClase`:

<CodeSnippet>
  {`class AlgunaClase {
    class func algunMetodoDeTipo() {
        // La implementación del método tipo va aquí
    }
}\n
AlgunaClase.algunMetodoDeTipo()`}
</CodeSnippet>

Dentro del cuerpo de un método de tipo, la propiedad implícita `self` se refiere al tipo mismo, en lugar de a una instancia de ese tipo. Esto significa que puedes usar `self` para diferenciar entre propiedades de tipo parámetros de métodos de tipo, tal y como haces con las propiedades de instancia y los parámetros de los métodos de instancia.

Generalmente, cualquier método no cualificado y nombres de propiedades que usas dentro del cuerpo de un método de tipo se referirán a otro método de tipo nivel y propiedades. Un método de tipo puede llamar a otro método de tipo con el otro nombre del método, sin la necesidad del añadir el prefijo con el nombre del tipo. De forma similar, los métodos de tipo en estructuras y enumeraciones pueden acceder a las propiedades de tipo usando el nombre de la propiedad tipo sin el prefijo del nombre del tipo. 

El ejemplo más abajo define una estructura llamada `RegistroDeNivel`, que registra el progreso de un jugador a través de diferentes niveles o fases de un juego. Es un juego individual, pero puede almacenar información para múltiples jugadores en un único dispositivo.

Todos los niveles del juego (excepto el nivel uno) están bloqueados cuando se juega por primera vez. Cada vez que un jugador finaliza un nivel, ese nivel se desbloquea para todos los jugadores en el dispositivo. La estructura `RegistroDeNivel` usa propiedades y métodos de tipo para mantener el registro de qué niveles del juego han sido desbloqueados. También registra el nivel actual para el jugador individual.

<CodeSnippet>
  {`struct RegistroDeNivel {
    static var nivelMasAltoDesbloqueado = 1
    var nivelActual = 1\n
    static func desbloquear(_ nivel: Int) {
        if nivel > nivelMasAltoDesbloqueado { nivelMasAltoDesbloqueado = nivel }
    }\n
    static func estaDesbloqueado(_ nivel: Int) -> Bool {
        return nivel <= nivelMasAltoDesbloqueado
    }\n
    @discardableResult
    mutating func avanzar(a nivel: Int) -> Bool {
        if RegistroDeNivel.estaDesbloqueado(nivel) {
            nivelActual = nivel\n
            return true
        } else {
            return false
        }
    }
}`}
</CodeSnippet>

La estructura `RegistroDeNivel` mantiene el registro del nivel más alto que un jugador ha desbloqueado. Este valor se almacena en una propiedad de tipo llamada `nivelMasAltoDesbloqueado`.

`RegistroDeNivel` también define dos funciones de tipo para trabajar con la propiedad `nivelMasAltoDesbloqueado`. La primera es una función de tipo llamada `desbloquear(_:)`. que actualiza el valor de `nivelMasAltoDesbloqueado` cuando un nuevo nivel se desbloquea. La segunda es una función de tipo de conveniencia llamada `estaDesbloqueado(_:)`, que devuelve verdadero si un número particular de nivel ya ha sido desbloqueado (Fíjate que esos métodos de tipo pueden acceder a la propiedad de tipo `nivelMasAltoDesbloqueado`) sin que necesites escribirlo como `RegistroDeNivel.nivelMasAltoDesbloqueado`)

Además de su propiedad de tipo y sus métodos de tipo, `RegistroDeNivel` registra el progreso individual de los jugadores a través del juego. Usa una propiedad de instancia llamada `nivelActual` para registrar el nivel actual que un jugador está jugando.

Para ayudar a gestionar la propiedad `nivelActual`, `RegistroDeNivel` define un método de instancia llamado `avanzar(a:)`. Antes de actualizar `nivelActual`, este método comprueba si el nuevo nivel solicitado ya está desbloqueado. El método `avanzar(a:)` devuelve un valor Bool que indica si actualmente es capaz o no de establecer `nivelActual`. Ya que no es necesario un error para el código que llama al método `avanzar(a:)` para ignorar el valor de retorno, está función está marcada con el atributo `@discardableResult`. Para más información sobre este atributo, mira [Atributos](./atributos).

La estructura `RegistroDeNivel` se usa con la clase `Jugador`, mostrada más abajo, para registrar y actualizar el progreso de un jugador individual:

<CodeSnippet>
  {`class Jugador {
    var regitro = RegistroDeNivel()
    let nombreJugador: String\n
    func completar(nivel: Int) {
        RegistroDeNivel.desbloquear(nivel + 1)
        registro.avanzar(a: nivel + 1)
    }\n
    init(nombre: String) {
        nombreJugador = nombre
    }
}`}
</CodeSnippet>

La clase `Jugador` crea una nueva instancia de `RegistroDeNivel` para registrar el progreso de los jugadores. También facilita un método llamado `completar(nivel:)`, que es llamado cuando un jugador completa un nivel en particular. Este método desbloquea el siguiente nivel para todos los jugadores y actualiza el progreso del jugador para continuar al siguiente nivel (El valor de retorno Bool de `avanzar(a:)` se ignora, porque el nivel es conocido para haber sido desbloqueado por la llamada a `RegistroDeNivel.desbloquear()_:` en la linea anterior)

Puedes crear una instancia de la clase `Jugador` para un nuevo jugador, y ver qué ocurre cuando el jugador completa el nivel uno:

<CodeSnippet>
  {`var jugador = Jugador(nombre: "Argyrios")\n
jugador.completar(nivel: 1)\n
print("ahora el nivel más alto desbloqueado es \\(RegistroDeNivel.nivelMasAltoDesbloqueado)")
// Prints "ahora el nivel más alto desbloqueado es 2"`}
</CodeSnippet>

Si creas un segundo jugador, que intentes mover a un nivel que no ha sido aún desbloqueado por ningún jugador en el juego, el intento para establecer el nivel actual del jugador fallará:

<CodeSnippet>
  {`jugador = Jugador(nombre: "Beto")\n
  if jugador.registro.avanzar(a: 6) {
      print("el jugador está ahora en el nivel 6")
  } else {
      print("el nivel 6 no ha sido desbloqueado todavía")
  }
  // Imprime "el nivel 6 no ha sido desbloqueado todavía"`}
</CodeSnippet>

---
title: Funciones
---

import Callout from "../../components/Callout.js"
import CodeSnippet from "../../components/CodeSnippet.js"

# Funciones

Una _función_ es un segmento auto-contenido de código que ejecuta una tarea específica. A una función le asignas un nombre que comunique lo que esta hace, y usas dicho nombre para _llamar_ a la función y que esta ejecute su tarea, cuando sea necesario.

La sintaxis unificada de funciones de Swift es lo suficientemente flexible para expresar cualquier función —desde una sencilla, similar a las de C, sin nombres de parámetros, hasta un método complejo, del estilo de Objective-C, con nombres de argumentos y etiquetas para cada parámetro. Un parámetro puede proveer valores predeterminados que simplifican el llamado a una función, y pueden ser pasados como parámetros _in-out_, los cuales modifican una variable que les haya sido pasada una vez que la función haya completado su ejecución.

En Swift, cada función tiene un tipo, el cual se conforma por los tipos de los argumentos de la función y del valor devuelto por la misma. Este tipo, lo puedes usar como cualquier otro tipo en Swift, lo cual facilita pasar funciones como parámetros a otras funciones y devolver funciones desde otras funciones. Las funciones también pueden definirse dentro de otras funciones para encapsular funcionalidad útil dentro del ámbito de una función anidada.

## Definición y llamado de una función

Al definir una función, puedes especificar —de manera opcional— uno o más valores tipados y con nombre que la función recibirá como valores de entrada; a estos valores se les conoce como _parámetros_. También puedes definir —opcionalmente— un tipo de valor que la función devolverá como valor de salida, una vez finalice su ejecución; a dicho valor se le conoce como _valor devuelto_.

Cada función tiene un nombre, el cual describe la tarea que la función ejecuta. Para usar una función, debes _llamar_ a la función con su nombre y pasarle valores de entrada (conocidos como _argumentos_) que coincidan con el o los tipos de los parámetros de la función. Los argumentos de una función siempre deben proveerse en el mismo orden de la lista de parámetros de la función.

La función del siguiente ejemplo se llama `saludar(persona)`, ya que eso es lo que esta hace, toma el nombre de una persona como entrada y devuelve un saludo para esta persona. Para hacer esto, defines un parámetro de entrada, un valor de tipo `String` llamado `persona`, y un valor a devolver —de tipo `String`— llamado `saludo`, el cual contiene un saludo para la persona:

<CodeSnippet>
  {`func saludar(persona: String) -> String {
    let saludo = "¡Hola, " + persona + "!"\n
    return saludo
}`}
</CodeSnippet>

Toda esta información va dentro de la _definición_ de una función, la cual va precedida por la palabra clave `func`. Para indicar el tipo devuelto por la función, utiliza la _flecha de devolución_ (`->`) —un guión seguido de un signo _mayor que_—, seguida por el nombre del tipo a devolver.

La definición describe lo que la función hace, lo que espera recibir, y lo que devuelve al ejecutarse. La definición también facilita que la función pueda ser llamada desde cualquier lugar de tu código, evitando ambigüedades.

<CodeSnippet>
  {`print(saludar(persona: "Ana"))
// Imprime "¡Hola, Ana!"
print(saludar(persona: "Pedro"))
// Imprime "¡Hola, Pedro!"`}
</CodeSnippet>

Para llamar a la función `saludar(persona:)`, le pasas un valor de tipo `String` luego de la etiqueta del argumento `persona`, así: `saludar(persona: "Ana")`. Dado que la función devuelve una cadena, `saludar(persona:)` puede serle pasada a una llamada a la función `print(_:separator:terminator:)` para imprimir dicha cadena y ver su valor devuelto, como se ve en el ejemplo anterior.

<Callout>
  La función `print(_:separator:terminator:)` no tiene una etiqueta para su
  primer argumento y sus otros argumentos son opcionales, ya que estos cuentan
  con un valor predeterminado. Estas variantes de la sintaxis de una función se
  discuten más adelante en [Etiquetas de los argumentos y nombres de parámetros
  de una
  función](#etiquetas-de-los-argumentos-y-nombres-de-parámetros-de-una-función)
  y [Valores predeterminados de
  parámetros](#valores-predeterminados-de-parámetros).
</Callout>

El cuerpo de la función `saludar(persona)` empieza con la definición de una nueva constante —de tipo `String`— llamada `saludo`, a la que le es asignado un saludo de bienvenida sencillo. Luego, este saludo es devuelto por la función mediante la palabra clave `return`. En la línea de código que pone `return saludo`, la función finaliza su ejecución y devuelve el valor que `saludo` tenga en su momento.

Puedes llamar a la función `saludar(persona)` múltiples veces con distintos valores de entrada. En el ejemplo anterior, se aprecia lo que ocurre al llamar la función con los valores de entrada `"Ana"` y `"Pedro"`. La función devuelve un saludo personalizado en cada caso.

Para acortar el cuerpo de esta función, puedes combinar la creación del mensaje y la instrucción de devolución en una sola línea:

<CodeSnippet>
  {`func saludarOtraVez(persona: String) -> String {
    return "¡Hola, nuevamente, " + persona + "!"
}\n
print(saludarOtraVez(persona: "Ana"))
// Imprime "¡Hola, nuevamente, Ana!"`}
</CodeSnippet>

## Parámetros de funciones y valores devueltos

Los parámetros y los valores devueltos de las funciones son extremadamente flexibles en Swift. Puedes definir cualquier función desde una función utilitaria con un único parámetro anónimo hasta una función compleja con nombres de parámetros expresivos y diferentes opciones para dichos parámetros.

### Funciones sin parámetros

Las funciones no requieren la definición de parámetros de entrada. Acá se tiene una función sin parámetros de entrada, la cual siempre devuelve el mismo mensaje `String` al ser llamada:

<CodeSnippet>
  {`func decirHolaMundo() -> String {
    return "Hola, mundo."
}\n
print(decirHolaMundo())
// Imprime "Hola, mundo."`}
</CodeSnippet>

La definición de la función requiere de paréntesis aun cuando esta no toma ningún parámetro. El nombre de la función también va seguido de un par de paréntesis al momento de llamar a la función.

### Funciones con múltiples parámetros

Las funciones pueden tener múltiples parámetros de entrada, los cuales se escriben dentro de los paréntesis de la función, separados por coma.

Esta función toma como entrada el nombre de una persona y un indicador de que ya se ha saludado o no a dicha persona, y devuelve un saludo apropiado para la persona:

<CodeSnippet>
  {`func saludar(persona: String, fueSaludada: Bool) -> String {
    if fueSaludada {
        return saludarNuevamente(persona: persona)
    } else {
        return saludar(persona: persona)
    }
}\n
print(saludar(persona: "Cindy", fueSaludada: true))
// Imprime "¡Hola otra vez, Cindy!"`}
</CodeSnippet>

Para llamar a la función `saludar(persona:fueSaludada:)`, le pasas un valor argumento de tipo `String`, con la etiqueta `persona` y un valor argumento de tipo `Bool`, con la etiqueta `fueSaludada` — en paréntesis y separados por coma. Observa que esta función es diferente a la función `saludar(persona)` que se mostró en una sección anterior. Aunque el nombre de ambas funciones empieza por `saludar`, la función `saludar(persona:fueSaludada:)` toma dos argumentos, mientras que la función `saludar(persona:)` solo toma uno.

### Funciones sin valores devueltos

Las funciones no requieren definir un tipo a devolver. Aquí tenemos una versión de la función `saludar(persona:)`, la cual imprime su propia cadena en lugar de devolverla:

<CodeSnippet>
  {`func saludar(persona: String) {
    print("¡Hola, \\(persona)!")
}\n
saludar(persona: "Daniel")
// Imprime "¡Hola, Daniel!"`}
</CodeSnippet>

Dado que no necesita devolver un valor, la definición de la función no incluye la flecha de devolución (`->`) o un tipo a devolver.

<Callout>
  Estrictamente hablando, esta versión de la función `saludar(persona:)` _sí_
  devuelve un valor, aun cuando no se definió un valor a devolver. Las funciones
  que no definen un valor a devolver, devuelven un valor especial de tipo
  `Void`. Esto es, simplemente, una tupla vacía — la cual se escribe como `()`.
</Callout>

El valor devuelto por una función puede ignorarse al llamar a la función:

<CodeSnippet>
  {`func imprimirYContar(cadena: String) -> Int {
    print(cadena)\n
    return cadena.count
}\n
func imprimirSinContar(cadena: String) {
    let _ = imprimirYContar(cadena: string)
}\n
// Imprime «Hola, mundo» y devuelve un valor de 12
imprimirYContar(cadena: "Hola, mundo")\n
// Imprime «Hola, mundo», pero no devuelve un valor
imprimirSinContar(cadena: "Hola, mundo")`}
</CodeSnippet>

La primera función —`imprimirYContar(cadena:)`— imprime una cadena y luego devuelve su número de caracteres como un `Int`. La segunda función — `imprimirSinContar(cadena:)`— llama a la primera función, pero ignora su valor devuelto. Cuando se llama a la segunda función, el mensaje es impreso por la primera función, pero no se utiliza su valor devuelto.

<Callout>
  Los valores devueltos pueden ignorarse, pero una función que indica que
  devolverá un valor, siempre debe hacerlo. Una función con un valor devuelto
  definido no puede permitir que el control vaya más allá del final de la
  función sin devolver un valor e intentar hacer esto resultará en un error de
  tiempo de compilación.
</Callout>

### Funciones con múltiples valores devueltos

Es posible usar una tupla como el tipo devuelto por una función para devolver múltiples valores como parte de un solo valor devuelto compuesto.

El siguiente ejemplo define una función llamada `minMax(array:)`, la cual encuentra los números menor y mayor en un _array_ de valores `Int`:

<CodeSnippet>
  {`func minMax(array: [Int]) -> (min: Int, max: Int) {
    var minimoActual = array[0]
    var maximoActual = array[0]\n
    for valor in array[1..<array.count] {
        if valor < minimoActual {
            minimoActual = valor
        } else if valor > maximoActual {
            maximoActual = valor
        }
    }\n
    return (minimoActual, maximoActual)
}`}
</CodeSnippet>

La función `minMax(array:)` devuelve una tupla que contiene dos valores `Int`. Estos valores se etiquetan `min` y `max` de manera que se puede acceder a ellos por su nombre al llamar al valor devuelto por la función.

El cuerpo de la función `minMax(array:)` empieza asignando a dos variables llamadas `minimoActual` y `maximoActual` el valor del primer entero en el _array_. La función luego itera sobre los demás valores del _array_ y verifica cada valor para determinar si es menor o mayor que los valores de `minimoActual` y `maximoActual`, respectivamente. Finalmente, los valores mínimo y máximo son devueltos como una tupla de dos valores `Int`.

Dado que a los valores que conforman la tupla se le asignaron nombres como parte del valor devuelto por la función, a estos se puede acceder mediante sintaxis de punto para obtener los valores mínimos y máximo que se hallaron:

<CodeSnippet>
  {`let limites = minMax(array: [8, -6, 2, 109, 3, 71])\n
print("min es \\(limites.min) y max es \\(bounds.max)")
// Imprime «min es -6 y max es 109"`}
</CodeSnippet>

Observa que no hace falta nombrar a los miembros de la tupla en el momento en que la tupla es devuelta por la función ya que sus nombres han sido previamente especificados como parte del valor devuelto de la función.

#### Tuplas devueltas opcionales

Si el valor tipo tupla a devolver por una función tiene el potencial de no contener «ningún valor» para toda la tupla, puedes devolver una tupla _opcional_ para reflejar el hecho de que toda la tupla puede ser `nil`. Puedes indicar una tupla devuelta opcional al colocar un signo de interrogación (de cierre) después del paréntesis de cierre de la tupla, así `(Int, Int)?` o `(String, Int, Bool)?`.

<Callout>
  Un valor tipo tupla opcional como `(Int, Int)?` es diferente de una tupla que
  contiene tipos opcionales como `(Int?, Int?)`. Para un valor tipo tupla
  opcional, toda la tupla es opcional y no solo cada valor individual dentro de
  la tupla.
</Callout>

La función `minMax(array:)` vista anteriormente devuelve una tupla que contiene dos valores `Int`. Sin embargo, la función no realiza ninguna verificación de seguridad sobre el _array_ que recibe. Si el argumento `array` fuese un _array_ vacío, la función `minMax(array:)` —tal como se define arriba— arrojaría un error de tiempo de ejecución al intentar acceder a `array[0]`.

Para lidiar —de manera segura— con un _array_ vacío, escribe la función `minMax(array:)` con una tupla opcional como valor a devolver y un valor a devolver de `nil` cuando el _array_ esté vacío:

<CodeSnippet>
  {`func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }\n
    var minimoActual = array[0]
    var maximoActual = array[0]\n
    for valor in array[1..<array.count] {
        if valor < minimoActual {
            minimoActual = valor
        } else if valor > maximoActual {
            maximoActual = valor
        }
    }\n
    return (minimoActual, maximoActual)
}`}
</CodeSnippet>

Puedes utilizar encadenamiento opcional para verificar si la versión de la función `minMax(array:)` devuelve una tupla real o `nil`:

<CodeSnippet>
  {`if let limites = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print("min es \\(limites.min) y max es \\(limites.max)")
}
// Imprime «min es -6 y max es 109»`}
</CodeSnippet>

### Funciones con un valor devuelto implícito

Si todo el cuerpo de una función es una sola expresión, la función —implícitamente— devuelve dicha expresión. Por ejemplo, las dos siguientes funciones tienen el mismo comportamiento:

<CodeSnippet>
  {`func saludo(para persona: String) -> String {
    "¡Hola, " + persona + "!"
}\n
print(saludo(para: "Andrea"))
// Imprime «¡Hola, Andrea!»\n
func otroSaludo(para persona: String) -> String {
    return "¡Hola, " + persona + "!"
}\n
print(otroSaludo(para: "Andrea"))
// Imprime «¡Hola, Andrea!»`}
</CodeSnippet>

Toda la definición de la función `saludo(para:)` es el mensaje de saludo que esta devuelve, lo que le permite usar esta forma abreviada. La función `otroSaludo(para:)` devuelve el mismo mensaje de saludo usando la palabra clave `return` como una función más extensa. Para cualquier función que escribas como una sola línea que devuelve algo, puedes omitir `return`.

Como verás en [Declaración concisa de getters](./propiedades#declaracion-concisa-de-getters), los _getters_ de propiedades también pueden omitir un `return` implícito.

<Callout>
  El código que escribas como un valor devuelto implícito tiene que devolver
  algún valor. Por ejemplo, no puedes usar `errorFatal("¡Oh, no!")` o
  `print(13)` como valor devuelto implícito.
</Callout>

## Etiquetas de argumentos y nombres de parámetros de funciones

Cada parámetro de una función tiene tanto una _etiqueta de argumento_ como un _nombre de parámetro_. La etiqueta de argumento se usa al invocar una función — cada argumento se escribe en la llamada de la función con su etiqueta de argumento precediéndole. El nombre del parámetro se utiliza en la implementación de la función. Por defecto, los parámetros utilizan su nombre de parámetro como su etiqueta de argumento.

<CodeSnippet>
  {`func algunaFuncion(nombrePrimerParametro: Int, nombreSegundoParametro: Int) {
    // En el cuerpo de la función, nombrePrimerParametro y nombreSegundoParametro
    // se refieren a los valores argumento del primer y segundo parámetros.
}\n
algunaFuncion(nombrePrimerParametro: 1, nombreSegundoParametro: 2)`}
</CodeSnippet>

Todos los parámetros deben tener nombres únicos. Aunque es posible que múltiples parámetros tengan la misma etiqueta de argumento, tener etiquetas de argumentos únicas ayuda a que tu código sea más legible.

### Especificando etiquetas de argumentos

Debes definir una etiqueta de argumento antes del nombre del parámetro, separados por un espacio:

<CodeSnippet>
  {`func algunaFuncion(etiquetaArgumento nombreParametro: Int) {
    // En el cuerpo de la función, nombreParametro hace referencia al
    // valor argumento para dicho parámetro.
}`}
</CodeSnippet>

Acá vemos una variante de la función `saludar(persona:)`, la cual toma el nombre y lugar de origen de una persona, y devuelve un saludo:

<CodeSnippet>
  {`func saludar(persona: String, de lugarOrigen: String) -> String {
    return "¡Hola, \\(persona)!  Es un placer que puedas visitarnos desde \\(lugarOrigen)."
}\n
print(saludar(persona: "Luisa", from: "Cupertino"))
// Prints «¡Hola, Luisa! Es un placer que puedas visitarnos desde Cupertino.»`}
</CodeSnippet>

El uso de etiquetas de argumento permiten que una función pueda ser llamada de manera expresiva, como una instrucción, mientras provee un cuerpo legible y de clara intención.

### Omitiendo etiquetas de argumentos

Si no quieres una etiqueta de argumento para un parámetro, agrega un guión bajo (`_`) en lugar de una etiqueta de argumento explícita para dicho parámetro.

<CodeSnippet>
  {`func algunaFuncion(_ primerNombreParametro: Int, segundoNombreParametro: Int) {
    // En el cuerpo de la función, primerNombreParametro y segundoNombreParametro
    // se refieren a los valores argumento para el primer y segundo parámetros.
}\n
algunaFuncion(1, segundoNombreParametro: 2)`}
</CodeSnippet>

Si un parámetro tiene una etiqueta de argumento, el argumento _debe_ ir acompañado de la etiqueta al momento de llamar la función.

### Valores parámetro predeterminados

Puedes definir un _valor predeterminado_ para cualquier parámetro de una función, asignando un valor al parámetro después del tipo del parámetro. Si un valor predeterminado ya se ha definido, puedes omitir el parámetro al invocar la función.

<CodeSnippet>
  {`func algunaFuncion(parametroSinValorPredeterminado: Int, parametroConValorPredeterminado: Int = 12) {
    // Si omites el segundo argumento al invocar la función, entonces
    // el valor de parametroConValorPredeterminado será 12 dentro del
    // cuerpo de la función.
}\n
algunaFuncion(parametroSinValorPredeterminado: 3, parametroConValorPredeterminado: 6) // parametroConValorPredeterminado es 6
algunaFuncion(parametroSinValorPredeterminado: 4) // parametroConValorPredeterminado es 12`}
</CodeSnippet>

Coloca los parámetros que no tienen valor predeterminado al inicio de la lista de parámetros de una función, antes de los parámetros que sí tienen valores predeterminados. Los parámetros que no tienen valores predeterminados suelen ser más importantes para el significado de la función, por lo que al escribirlos primero, resulta más fácil identificar cuando la misma función está siendo llamada, independientemente de que se omita o no algún parámetro predeterminado.

### Variadic Parameters

A _variadic parameter_ accepts zero or more values of a specified type. You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called. Write variadic parameters by inserting three period characters (`...`) after the parameter's type name.

The values passed to a variadic parameter are made available within the function's body as an array of the appropriate type. For example, a variadic parameter with a name of `numbers` and a type of `Double...` is made available within the function's body as a constant array called `numbers` of type `[Double]`.

The example below calculates the _arithmetic mean_ (also known as the _average_) for a list of numbers of any length:

<CodeSnippet>
  {`func arithmeticMean(_ numbers: Double...) -> Double {
    var total: Double = 0\n
    for number in numbers {
        total += number
    }\n
    return total / Double(numbers.count)
}\n
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers`}
</CodeSnippet>

A function can have multiple variadic parameters. The first parameter that comes after a variadic parameter must have an argument label. The argument label makes it unambiguous which arguments are passed to the variadic parameter and which arguments are passed to the parameters that come after the variadic parameter.

### In-Out Parameters

Function parameters are constants by default. Trying to change the value of a function parameter from within the body of that function results in a compile-time error. This means that you can't change the value of a parameter by mistake. If you want a function to modify a parameter's value, and you want those changes to persist after the function call has ended, define that parameter as an _in-out parameter_ instead.

You write an in-out parameter by placing the `inout` keyword right before a parameter's type. An in-out parameter has a value that's passed _in_ to the function, is modified by the function, and is passed back _out_ of the function to replace the original value. For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see [In-Out Parameters](../referencia-del-lenguaje/declaraciones#parametros-in-out).

You can only pass a variable as the argument for an in-out parameter. You can't pass a constant or a literal value as the argument, because constants and literals can't be modified. You place an ampersand (`&`) directly before a variable's name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.

<Callout>
  In-out parameters can't have default values, and variadic parameters can't be
  marked as `inout`.
</Callout>

Here's an example of a function called `swapTwoInts(_:_:)`, which has two in-out integer parameters called `a` and `b`:

<CodeSnippet>
  {`func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}`}
</CodeSnippet>

The `swapTwoInts(_:_:)` function simply swaps the value of `b` into `a`, and the value of `a` into `b`. The function performs this swap by storing the value of `a` in a temporary constant called `temporaryA`, assigning the value of `b` to `a`, and then assigning `temporaryA` to `b`.

You can call the `swapTwoInts(_:_:)` function with two variables of type `Int` to swap their values. Note that the names of `someInt` and `anotherInt` are prefixed with an ampersand when they're passed to the `swapTwoInts(_:_:)` function:

<CodeSnippet>
  {`var someInt = 3
var anotherInt = 107\n
swapTwoInts(&someInt, &anotherInt)\n
print("someInt is now \\(someInt), and anotherInt is now \\(anotherInt)")
// Prints "someInt is now 107, and anotherInt is now 3"`}
</CodeSnippet>

The example above shows that the original values of `someInt` and `anotherInt` are modified by the `swapTwoInts(_:_:)` function, even though they were originally defined outside of the function.

<Callout>
  In-out parameters aren't the same as returning a value from a function. The
  `swapTwoInts` example above doesn't define a return type or return a value,
  but it still modifies the values of `someInt` and `anotherInt`. In-out
  parameters are an alternative way for a function to have an effect outside of
  the scope of its function body.
</Callout>

## Function Types

Every function has a specific _function type_, made up of the parameter types and the return type of the function.

For example:

<CodeSnippet>
  {`func addTwoInts(_ a: Int, _ b: Int) -> Int {
    return a + b
}\n
func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {
    return a * b
}`}
</CodeSnippet>

This example defines two simple mathematical functions called `addTwoInts` and `multiplyTwoInts`. These functions each take two `Int` values, and return an `Int` value, which is the result of performing an appropriate mathematical operation.

The type of both of these functions is `(Int, Int) -> Int`. This can be read as:

“A function that has two parameters, both of type `Int`, and that returns a value of type `Int`.”

Here's another example, for a function with no parameters or return value:

<CodeSnippet>
  {`func printHelloWorld() {
    print("hello, world")
}`}
</CodeSnippet>

The type of this function is `() -> Void`, or “a function that has no parameters, and returns `Void`.”

### Using Function Types

You use function types just like any other types in Swift. For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:

<CodeSnippet>{`var mathFunction: (Int, Int) -> Int = addTwoInts`}</CodeSnippet>

This can be read as:

“Define a variable called `mathFunction`, which has a type of 'a function that takes two `Int` values, and returns an `Int` value.' Set this new variable to refer to the function called `addTwoInts`.”

The `addTwoInts(_:_:)` function has the same type as the `mathFunction` variable, and so this assignment is allowed by Swift's type-checker.

You can now call the assigned function with the name `mathFunction`:

<CodeSnippet>
  {`print("Result: \\(mathFunction(2, 3))")
// Prints "Result: 5"`}
</CodeSnippet>

A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:

<CodeSnippet>
  {`mathFunction = multiplyTwoInts\n
print("Result: \\(mathFunction(2, 3))")
// Prints "Result: 6"`}
</CodeSnippet>

As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:

<CodeSnippet>
  {`let anotherMathFunction = addTwoInts
// anotherMathFunction is inferred to be of type (Int, Int) -> Int`}
</CodeSnippet>

### Function Types as Parameter Types

You can use a function type such as `(Int, Int) -> Int` as a parameter type for another function. This enables you to leave some aspects of a function's implementation for the function's caller to provide when the function is called.

Here's an example to print the results of the math functions from above:

<CodeSnippet>
  {`func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \\(mathFunction(a, b))")
}\n
printMathResult(addTwoInts, 3, 5)
// Prints "Result: 8"`}
</CodeSnippet>

This example defines a function called `printMathResult(_:_:_:)`, which has three parameters. The first parameter is called mathFunction, and is of type (Int, Int) -> Int. You can pass any function of that type as the argument for this first parameter. The second and third parameters are called a and b, and are both of type Int. These are used as the two input values for the provided math function.

When `printMathResult(_:_:_:)` is called, it's passed the `addTwoInts(_:_:)` function, and the integer values `3` and `5`. It calls the provided function with the values `3` and `5`, and prints the result of `8`.

The role of `printMathResult(_:_:_:)` is to print the result of a call to a math function of an appropriate type. It doesn't matter what that function's implementation actually does—it matters only that the function is of the correct type. This enables `printMathResult(_:_:_:)` to hand off some of its functionality to the caller of the function in a type-safe way.

### Function Types as Return Types

You can use a function type as the return type of another function. You do this by writing a complete function type immediately after the return arrow (`->`) of the returning function.

The next example defines two simple functions called `stepForward(_:)` and `stepBackward(_:)`. The `stepForward(_:)` function returns a value one more than its input value, and the `stepBackward(_:)` function returns a value one less than its input value. Both functions have a type of `(Int) -> Int`:

<CodeSnippet>
  {`func stepForward(_ input: Int) -> Int {
    return input + 1
}\n
func stepBackward(_ input: Int) -> Int {
    return input - 1
}`}
</CodeSnippet>

Here's a function called `chooseStepFunction(backward:)`, whose return type is `(Int) -> Int`. The `chooseStepFunction(backward:)` function returns the `stepForward(_:)` function or the `stepBackward(_:)` function based on a Boolean parameter called `backward`:

<CodeSnippet>
  {`func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return backward ? stepBackward : stepForward
}`}
</CodeSnippet>

You can now use `chooseStepFunction(backward:)` to obtain a function that will step in one direction or the other:

<CodeSnippet>
  {`var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the stepBackward() function`}
</CodeSnippet>

The example above determines whether a positive or negative step is needed to move a variable called `currentValue` progressively closer to zero. `currentValue` has an initial value of `3`, which means that `currentValue > 0` returns `true`, causing `chooseStepFunction(backward:)` to return the `stepBackward(_:)` function. A reference to the returned function is stored in a constant called `moveNearerToZero`.

Now that `moveNearerToZero` refers to the correct function, it can be used to count to zero:

<CodeSnippet>
  {`print("Counting to zero:")
// Counting to zero:\n
while currentValue != 0 {
    print("\\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}\n
print("zero!")
// 3...
// 2...
// 1...
// zero!`}
</CodeSnippet>

## Nested Functions

All of the functions you have encountered so far in this chapter have been examples of _global functions_, which are defined at a global scope. You can also define functions inside the bodies of other functions, known as _nested functions_.

Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.

You can rewrite the `chooseStepFunction(backward:)` example above to use and return nested functions:

<CodeSnippet>
  {`func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }\n
    return backward ? stepBackward : stepForward
}\n
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the nested stepForward() function\n
while currentValue != 0 {
    print("\\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}\n
print("zero!")
// -4...
// -3...
// -2...
// -1...
// zero!`}
</CodeSnippet>

---
title: Funciones
---

import Callout from '../../components/Callout.js'
import CodeSnippet from '../../components/CodeSnippet.js'

# Funciones

Una _función_ es un segmento auto-contenido de código que ejecuta una tarea específica. A una función le das un nombre que comunica lo que esta hace, y usas dicho nombre para _llamar_ a la función y que esta ejecute su tarea, cuando sea necesario.

La sintaxis unificada de funciones de Swift es lo suficientemente flexible para expresar cualquier función —desde una sencilla, similar a las de C, sin nombres de parámetros, hasta un método complejo, del estilo de Objective-C, con nombres de argumentos y etiquetas para cada parámetro. Un parámetro puede proveer valores predeterminados que simplifican el llamado a una función, y pueden ser pasados como parámetros _in-out_, los cuales modifican una variable que les haya sido pasada una vez que la función haya completado su ejecución.

En Swift, cada función tiene un tipo, el cual se conforma por los tipos de los argumentos de la función y del valor de devolución de la misma. Este tipo, lo puedes usar como cualquier otro tipo en Swift, lo cual facilita pasar funciones como parámetros a otras funciones y devolver funciones desde otras funciones. Las funciones también pueden definirse dentro de otras funciones para encapsular funcionalidad útil dentro del ámbito de una función anidada.

## Definición y llamado de una función

Al definir una función, puedes especificar —de manera opcional— uno o más valores tipados y con nombre que la función recibirá como valores de entrada; a estos valores se les conoce como _parámetros_. También puedes definir —opcionalmente— un tipo de valor que la función devolverá como valor de salida, una vez finalice su ejecución; a dicho valor se le conoce como _valor de devolución_.

Cada función tiene un nombre, el cual describe la tarea que la función ejecuta. Para usar una función, debes _llamar_ a la función con su nombre y pasarle valores de entrada (conocidos como _argumentos_) que coincidan con el o los tipos de los parámetros de la función. Los argumentos de una función siempre deben proveerse en el mismo orden de la lista de parámetros de la función.

La función del siguiente ejemplo se llama `saludar(persona)`, ya que eso es lo que esta hace, toma el nombre de una persona como entrada y devuelve un saludo para esta persona. Para hacer esto, defines un parámetro de entrada, un valor de tipo `String` llamado `persona`, y un valor a devolver —de tipo `String`— llamado `saludo`, el cual contiene un saludo para la persona:

<CodeSnippet>
  {`func saludar(persona: String) -> String {
    let saludo = "¡Hola, " + persona + "!"\n
    return saludo
}`}
</CodeSnippet>

Toda esta información va dentro de la _definición_ de una función, la cual va precedida por la palabra clave `func`. Para indicar el tipo de devolución de una función, utiliza la _flecha de devolución_ (`->`) —un guión seguido de un signo _mayor que_—, seguida por el nombre del tipo a devolver.

La definición describe lo que la función hace, lo que espera recibir, y lo que devuelve al ejecutarse. La definición también facilita que la función pueda ser llamada desde cualquier lugar de tu código, evitando ambigüedades.

<CodeSnippet>
  {`print(saludar(persona: "Ana"))
// Imprime «¡Hola, Ana!»
print(saludar(persona: "Pedro"))
// Imprime «¡Hola, Pedro!»`}
</CodeSnippet>

Para llamar a la función `saludar(persona:)`, le pasas un valor de tipo `String` luego de la etiqueta del argumento `persona`, así: `saludar(persona: "Ana")`. Dado que la función devuelve una cadena, `saludar(persona:)` puede serle pasada a una llamada a la función `print(_:separator:terminator:)` para imprimir dicha cadena y ver su valor de devolución, como se ve en el ejemplo anterior.

<Callout>
  La función `print(_:separator:terminator:)` no tiene una etiqueta para su
  primer argumento y sus otros argumentos son opcionales, ya que estos cuentan
  con un valor predeterminado. Estas variantes de la sintaxis de una función se
  discuten más adelante en [Etiquetas de los argumentos y nombres de parámetros
  de una
  función](#etiquetas-de-los-argumentos-y-nombres-de-parámetros-de-una-función)
  y [Valores de parámetros
  predeterminados](#valores-de-parámetros-predeterminados).
</Callout>

El cuerpo de la función `saludar(persona)` empieza con la definición de una nueva constante —de tipo `String`— llamada `saludo`, a la que le es asignado un saludo de bienvenida sencillo. Luego, este saludo es devuelto por la función mediante la palabra clave `return`. En la línea de código que pone `return saludo`, la función finaliza su ejecución y devuelve el valor que `saludo` tenga en su momento.

Puedes llamar a la función `saludar(persona)` múltiples veces con distintos valores de entrada. En el ejemplo anterior, se aprecia lo que ocurre al llamar la función con los valores de entrada `"Ana"` y `"Pedro"`. La función devuelve un saludo personalizado en cada caso.

Para acortar el cuerpo de esta función, puedes combinar la creación del mensaje y la instrucción de devolución en una sola línea:

<CodeSnippet>
  {`func saludarOtraVez(persona: String) -> String {
    return "¡Hola, nuevamente, " + persona + "!"
}\n
print(saludarOtraVez(persona: "Ana"))
// Imprime «¡Hola, nuevamente, Ana!»`}
</CodeSnippet>

## Parámetros de funciones y valores de devolución

Los parámetros y los valores de devolución de las funciones son extremadamente flexibles en Swift. Puedes definir cualquier función desde una función utilitaria con un único parámetro anónimo hasta una función compleja con nombres de parámetros expresivos y diferentes opciones para dichos parámetros.

### Funciones sin parámetros

Las funciones no requieren la definición de parámetros de entrada. Acá se tiene una función sin parámetros de entrada, la cual siempre devuelve el mismo mensaje `String` al ser llamada:

<CodeSnippet>
  {`func decirHolaMundo() -> String {
    return "Hola, mundo."
}\n
print(decirHolaMundo())
// Imprime «Hola, mundo.»`}
</CodeSnippet>

La definición de la función requiere de paréntesis aun cuando esta no toma ningún parámetro. El nombre de la función también va seguido de un par de paréntesis al momento de llamar a la función.

### Funciones con múltiples parámetros

Las funciones pueden tener múltiples parámetros de entrada, los cuales se escriben dentro de los paréntesis de la función, separados por coma.

Esta función toma como entrada el nombre de una persona y un indicador de que ya se ha saludado o no a dicha persona, y devuelve un saludo apropiado para la persona:

<CodeSnippet>
  {`func saludar(persona: String, fueSaludada: Bool) -> String {
    if fueSaludada {
        return saludarNuevamente(persona: persona)
    } else {
        return saludar(persona: persona)
    }
}\n
print(saludar(persona: "Cindy", fueSaludada: true))
// Imprime «¡Hola otra vez, Cindy!»`}
</CodeSnippet>

Para llamar a la función `saludar(persona:fueSaludada:)`, le pasas un valor argumento de tipo `String`, con la etiqueta `persona` y un valor argumento de tipo `Bool`, con la etiqueta `fueSaludada` — en paréntesis y separados por coma. Observa que esta función es diferente a la función `saludar(persona)` que se mostró en una sección anterior. Aunque el nombre de ambas funciones empieza por `saludar`, la función `saludar(persona:fueSaludada:)` toma dos argumentos, mientras que la función `saludar(persona:)` solo toma uno.

### Funciones sin valores de devolución

Las funciones no requieren definir un tipo de devolución. Aquí tenemos una versión de la función `saludar(persona:)`, la cual imprime su propia cadena en lugar de devolverla:

<CodeSnippet>
  {`func saludar(persona: String) {
    print("¡Hola, \\(persona)!")
}\n
saludar(persona: "Jorge")
// Imprime «¡Hola, Jorge!»`}
</CodeSnippet>

Dado que no necesita devolver un valor, la definición de la función no incluye la flecha de devolución (`->`) o un tipo de devolución.

<Callout>
  Estrictamente hablando, esta versión de la función `saludar(persona:)` _sí_
  devuelve un valor, aun cuando no se definió un valor a devolver. Las funciones
  que no definen un valor a devolver, devuelven un valor especial de tipo
  `Void`. Esto es, simplemente, una tupla vacía — la cual se escribe como `()`.
</Callout>

El valor de devolución de una función puede ignorarse al llamar a la función:

<CodeSnippet>
  {`func imprimirYContar(cadena: String) -> Int {
    print(cadena)\n
    return cadena.count
}\n
func imprimirSinContar(cadena: String) {
    let _ = imprimirYContar(cadena: string)
}\n
imprimirYContar(cadena: "Hola, mundo")
// Imprime «Hola, mundo» y devuelve un valor de 12\n
imprimirSinContar(cadena: "Hola, mundo")
// Imprime «Hola, mundo», pero no devuelve un valor`}
</CodeSnippet>

La primera función —`imprimirYContar(cadena:)`— imprime una cadena y luego devuelve su número de caracteres como un `Int`. La segunda función — `imprimirSinContar(cadena:)`— llama a la primera función, pero ignora su valor de devolución. Cuando se llama a la segunda función, el mensaje es impreso por la primera función, pero no se utiliza su valor de devolución.

<Callout>
  Los valores de devolución pueden ignorarse, pero una función que indica que
  devolverá un valor, siempre debe hacerlo. Una función con un valor de
  devolución definido no puede permitir que el control vaya más allá del final
  de la función sin devolver un valor e intentar hacer esto resultará en un
  error de tiempo de compilación.
</Callout>

### Funciones con múltiples valores de devolución

Es posible usar una tupla como el tipo de devolución de una función para devolver múltiples valores como parte de un solo valor de devolución compuesto.

El siguiente ejemplo define una función llamada `minMax(array:)`, la cual encuentra los números menor y mayor en un _array_ de valores `Int`:

<CodeSnippet>
  {`func minMax(array: [Int]) -> (min: Int, max: Int) {
    var minimoActual = array[0]
    var maximoActual = array[0]\n
    for valor in array[1..<array.count] {
        if valor < minimoActual {
            minimoActual = valor
        } else if valor > maximoActual {
            maximoActual = valor
        }
    }\n
    return (minimoActual, maximoActual)
}`}
</CodeSnippet>

La función `minMax(array:)` devuelve una tupla que contiene dos valores `Int`. Estos valores se etiquetan `min` y `max` de manera que se puede acceder a ellos por su nombre al referenciar al valor de devolución de la función.

El cuerpo de la función `minMax(array:)` empieza asignando a dos variables llamadas `minimoActual` y `maximoActual` el valor del primer entero en el _array_. La función luego itera sobre los demás valores del _array_ y verifica cada valor para determinar si es menor o mayor que los valores de `minimoActual` y `maximoActual`, respectivamente. Finalmente, los valores mínimo y máximo son devueltos como una tupla de dos valores `Int`.

Dado que a los valores que conforman la tupla se le asignaron nombres como parte del valor de devolución de la función, a estos se puede acceder mediante sintaxis de punto para obtener los valores mínimos y máximo que se hallaron:

<CodeSnippet>
  {`let limites = minMax(array: [8, -6, 2, 109, 3, 71])\n
print("min es \\(limites.min) y max es \\(bounds.max)")
// Imprime «min es -6 y max es 109"`}
</CodeSnippet>

Observa que no hace falta nombrar a los miembros de la tupla en el momento en que la tupla es devuelta por la función ya que sus nombres han sido previamente especificados como parte del valor de devolución de la función.

#### Tuplas de devolución opcionales

Si el valor del tipo tupla de devolución de una función tiene el potencial de no contener _ningún valor_ para toda la tupla, puedes devolver una tupla _opcional_ para reflejar el hecho de que toda la tupla puede ser `nil`. Puedes indicar una tupla devuelta opcional al colocar un signo de interrogación (de cierre) después del paréntesis de cierre de la tupla, así `(Int, Int)?` o `(String, Int, Bool)?`.

<Callout>
  Un valor tipo tupla opcional como `(Int, Int)?` es diferente de una tupla que
  contiene tipos opcionales como `(Int?, Int?)`. Para un valor tipo tupla
  opcional, toda la tupla es opcional y no solo cada valor individual dentro de
  la tupla.
</Callout>

La función `minMax(array:)` vista anteriormente devuelve una tupla que contiene dos valores `Int`. Sin embargo, la función no realiza ninguna verificación de seguridad sobre el _array_ que recibe. Si el argumento `array` fuese un _array_ vacío, la función `minMax(array:)` —tal como se define arriba— arrojaría un error de tiempo de ejecución al intentar acceder a `array[0]`.

Para lidiar —de manera segura— con un _array_ vacío, escribe la función `minMax(array:)` con una tupla opcional como valor a devolver y un valor a devolver de `nil` cuando el _array_ esté vacío:

<CodeSnippet>
  {`func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }\n
    var minimoActual = array[0]
    var maximoActual = array[0]\n
    for valor in array[1..<array.count] {
        if valor < minimoActual {
            minimoActual = valor
        } else if valor > maximoActual {
            maximoActual = valor
        }
    }\n
    return (minimoActual, maximoActual)
}`}
</CodeSnippet>

Puedes utilizar encadenamiento opcional para verificar si la versión de la función `minMax(array:)` devuelve una tupla real o `nil`:

<CodeSnippet>
  {`if let limites = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print("min es \\(limites.min) y max es \\(limites.max)")
}
// Imprime «min es -6 y max es 109»`}
</CodeSnippet>

### Funciones con un valor de devolución implícito

Si todo el cuerpo de una función es una sola expresión, la función —implícitamente— devuelve dicha expresión. Por ejemplo, las dos siguientes funciones tienen el mismo comportamiento:

<CodeSnippet>
  {`func saludo(para persona: String) -> String {
    "¡Hola, " + persona + "!"
}\n
print(saludo(para: "Andrea"))
// Imprime «¡Hola, Andrea!»\n
func otroSaludo(para persona: String) -> String {
    return "¡Hola, " + persona + "!"
}\n
print(otroSaludo(para: "Andrea"))
// Imprime «¡Hola, Andrea!»`}
</CodeSnippet>

Toda la definición de la función `saludo(para:)` es el mensaje de saludo que esta devuelve, lo que le permite usar esta forma abreviada. La función `otroSaludo(para:)` devuelve el mismo mensaje de saludo usando la palabra clave `return` como una función más extensa. Para cualquier función que escribas como una sola línea que devuelve algo, puedes omitir `return`.

Como verás en [Declaración concisa de getters](./propiedades#declaracion-concisa-de-getters), los _getters_ de propiedades también pueden omitir un `return` implícito.

<Callout>
  El código que escribas como un valor de devolución implícito tiene que
  devolver algún valor. Por ejemplo, no puedes usar `errorFatal("¡Oh, no!")` o
  `print(13)` como valor valor de devolución implícito.
</Callout>

## Etiquetas de argumentos y nombres de parámetros de funciones

Cada parámetro de una función tiene tanto una _etiqueta de argumento_ como un _nombre de parámetro_. La etiqueta de argumento se usa al invocar una función — cada argumento se escribe en la llamada de la función con su etiqueta de argumento precediéndole. El nombre del parámetro se utiliza en la implementación de la función. Por defecto, los parámetros utilizan su nombre de parámetro como su etiqueta de argumento.

<CodeSnippet>
  {`func algunaFuncion(nombrePrimerParametro: Int, nombreSegundoParametro: Int) {
    // En el cuerpo de la función, nombrePrimerParametro y nombreSegundoParametro
    // se refieren a los valores argumento del primer y segundo parámetros.
}\n
algunaFuncion(nombrePrimerParametro: 1, nombreSegundoParametro: 2)`}
</CodeSnippet>

Todos los parámetros deben tener nombres únicos. Aunque es posible que múltiples parámetros tengan la misma etiqueta de argumento, tener etiquetas de argumentos únicas ayuda a que tu código sea más legible.

### Especificando etiquetas de argumentos

Debes definir una etiqueta de argumento antes del nombre del parámetro, separados por un espacio:

<CodeSnippet>
  {`func algunaFuncion(etiquetaArgumento nombreParametro: Int) {
    // En el cuerpo de la función, nombreParametro hace referencia al
    // valor argumento para dicho parámetro.
}`}
</CodeSnippet>

Acá vemos una variante de la función `saludar(persona:)`, la cual toma el nombre y lugar de origen de una persona, y devuelve un saludo:

<CodeSnippet>
  {`func saludar(persona: String, de lugarOrigen: String) -> String {
    return "¡Hola, \\(persona)!  Es un placer que puedas visitarnos desde \\(lugarOrigen)."
}\n
print(saludar(persona: "Luisa", from: "Cupertino"))
// Prints «¡Hola, Luisa! Es un placer que puedas visitarnos desde Cupertino.»`}
</CodeSnippet>

El uso de etiquetas de argumento permiten que una función pueda ser llamada de manera expresiva, como una instrucción, mientras provee un cuerpo legible y de clara intención.

### Omitiendo etiquetas de argumentos

Si no quieres una etiqueta de argumento para un parámetro, agrega un guión bajo (`_`) en lugar de una etiqueta de argumento explícita para dicho parámetro.

<CodeSnippet>
  {`func algunaFuncion(_ primerNombreParametro: Int, segundoNombreParametro: Int) {
    // En el cuerpo de la función, primerNombreParametro y segundoNombreParametro
    // se refieren a los valores argumento para el primer y segundo parámetros.
}\n
algunaFuncion(1, segundoNombreParametro: 2)`}
</CodeSnippet>

Si un parámetro tiene una etiqueta de argumento, el argumento _debe_ ir acompañado de la etiqueta al momento de llamar la función.

### Valores de parámetros predeterminados

Puedes definir un _valor predeterminado_ para cualquier parámetro de una función, asignando un valor al parámetro después del tipo del parámetro. Si un valor predeterminado ya se ha definido, puedes omitir el parámetro al invocar la función.

<CodeSnippet>
  {`func algunaFuncion(parametroSinValorPredeterminado: Int, parametroConValorPredeterminado: Int = 12) {
    // Si omites el segundo argumento al invocar la función, entonces
    // el valor de parametroConValorPredeterminado será 12 dentro del
    // cuerpo de la función.
}\n
algunaFuncion(parametroSinValorPredeterminado: 3, parametroConValorPredeterminado: 6) // parametroConValorPredeterminado es 6
algunaFuncion(parametroSinValorPredeterminado: 4) // parametroConValorPredeterminado es 12`}
</CodeSnippet>

Coloca los parámetros que no tienen valor predeterminado al inicio de la lista de parámetros de una función, antes de los parámetros que sí tienen valores predeterminados. Los parámetros que no tienen valores predeterminados suelen ser más importantes para el significado de la función, por lo que al escribirlos primero, resulta más fácil identificar cuando la misma función está siendo llamada, independientemente de que se omita o no algún parámetro predeterminado.

### Parámetros _variadic_

Un parámetro _variadic_ acepta cero o más valores de un tipo específico. Puedes usar parámetros _variadic_ para especificar que al parámetro se le puede pasar un número variable de valores de entrada al momento de llamar la función. Escribe parámetros _variadic_ insertando tres puntos (`...`) después del tipo del parámetro:

Los valores que se le pasan a un parámetro _variadic_ estarán disponibles dentro del cuerpo de la función como un _array_ del tipo apropiado. Por ejemplo, un parámetro _variadic_ con el nombre de `numeros` y de tipo `Double...`, estará disponible dentro del cuerpo de la función como un _array_ constante, llamado `numeros`, de tipo `[Double]`.

En el siguiente ejemplo, se calcula la _media aritmética_ (también conocida como _promedio_) de una lista de números de cualquier tamaño:

<CodeSnippet>
  {`func mediaAritmetica(_ numeros: Double...) -> Double {
    var total: Double = 0\n
    for numero in numeros {
        total += numero
    }\n
    return total / Double(numeros.count)
}\n
mediaAritmetica(1, 2, 3, 4, 5)
// Devuelve 3.0, que es la media aritmética de esos cinco números.\n
mediaAritmetica(3, 8.25, 18.75)
// Devuelve 10.0, que es la media aritmética de esos tres números.`}
</CodeSnippet>

Una función puede tener múltiples parámetros _variadic_. El primer parámetro que le siga a un parámetro _variadic_ deberá tener una etiqueta de argumento. Una etiqueta de argumento elimina la ambigüedad sobre cuáles argumentos le son pasados al parámetro _variadic_ y cuáles le son pasados a los parámetros que le siguen al _variadic_.

### Parámetros _in-out_

Los parámetros de las funciones son, por defecto, constantes. Intentar cambiar el valor del parámetro de una función dentro del cuerpo de la función resultará en un error de tiempo de compilación. Esto significa que no puedes cambiar el valor de un parámetro por accidente. Si quieres que una función modifique el valor de un parámetro y que los cambios persistan después de finalizada la ejecución de la función, define dicho parámetro como un parámetro _in-out_.

Para definir un parámetro _in-out_, agrega la palabra clave `inout` justo antes del tipo del parámetro. Un parámetro _in-out_ tiene un valor que pasa a estar _dentro_ de la función, es modificado por dicha función, y pasa a estar _afuera_ de la función, para reemplazar al valor original. Para una discusión detallada sobre el comportamiento de los parámetros _in-out_ y sobre las optimizaciones de compilador asociadas, consulta [Parámetros in-out](../referencia-del-lenguaje/declaraciones#parámetros-in-out).

Solamente puedes pasar una variable como el argumento para un parámetro _in-out_. No es posible pasar una constante o un valor literal como argumento, ya que las constantes y los valores literales no pueden ser modificados. Al pasar una variable como argumento para un parámetro _in-out_, agrega el símbolo _ampersand_ (`&`) justo antes del nombre de la variable, para indicar que esta puede ser modificada por la función.

<Callout>
  Los parámetros _in-out_ no pueden tener valores predeterminados y los
  parámetros _variadic_ no pueden ser usados como parámetros _in-out_.
</Callout>

Acá tenemos un ejemplo con una función llamada `intercambiarDosInts(_:_:)`, la cual tiene dos parámetros _in-out_, enteros con nombres `a` y `b`.

<CodeSnippet>
  {`func intercambiarDosInts(_ a: inout Int, _ b: inout Int) {
    let aTemporal = a\n
    a = b
    b = aTemporal
}`}
</CodeSnippet>

La función `intercambiarDosInts(:_:_)` simplemente intercambia los valores de `a` y `b` entre sí. La función ejecuta este cambio slmscenando el valor de `a` en una constante temporal llamada `aTemporal`, y luego asigna el valor de `b` a `a`, y asigna el valor de `aTemporal` a `b`.

Puedes invocar a la función `intercambiarDosInts(_:_:)` con dos valores de tipo `Int` para intercambiar sus valores. Nota que los nombres de `algunInt` y `otroInt` van precedidos de un _ampersand_ al ser pasados como argumentos para la función `intercambiarDosInts(_:_:)`:

<CodeSnippet>
  {`var algunInt = 3
var otroInt = 107\n
intercambiarDosInts(&algunInt, &otroInt)\n
print("algunInt es ahora \\(algunInt), y otroInt es ahora \\(otroInt)")
// Imprime «algunInt es ahora 107, y otro Int es ahora 3»`}
</CodeSnippet>

El ejemplo anterior muestra que los valores originales de `algunInt` y `otroInt` fueron modificados por la función `intercambiarDosInts(_:_:)`, aun cuando estas variables se definieron fuera de la función.

<Callout>
  Los parámetros _in-out_ no son lo mismo que devolver valores desde una
  función. En el ejemplo anterior, la función `intercambiarDosInts(_:_:)` no
  define ningún valor o tipo a devolver, pero aun así, modifica los valores de
  `algunInt` y `otroInt`. Los parámetros _in-out_ son una forma alternativa de
  que una función tenga efectos fuera del ambiente definido por el cuerpo de la
  función.
</Callout>

## Function Types

Every function has a specific _function type_, made up of the parameter types and the return type of the function.

For example:

<CodeSnippet>
  {`func addTwoInts(_ a: Int, _ b: Int) -> Int {
    return a + b
}\n
func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {
    return a * b
}`}
</CodeSnippet>

This example defines two simple mathematical functions called `addTwoInts` and `multiplyTwoInts`. These functions each take two `Int` values, and return an `Int` value, which is the result of performing an appropriate mathematical operation.

The type of both of these functions is `(Int, Int) -> Int`. This can be read as:

“A function that has two parameters, both of type `Int`, and that returns a value of type `Int`.”

Here's another example, for a function with no parameters or return value:

<CodeSnippet>
  {`func printHelloWorld() {
    print("hello, world")
}`}
</CodeSnippet>

The type of this function is `() -> Void`, or “a function that has no parameters, and returns `Void`.”

### Using Function Types

You use function types just like any other types in Swift. For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:

<CodeSnippet>{`var mathFunction: (Int, Int) -> Int = addTwoInts`}</CodeSnippet>

This can be read as:

“Define a variable called `mathFunction`, which has a type of 'a function that takes two `Int` values, and returns an `Int` value.' Set this new variable to refer to the function called `addTwoInts`.”

The `addTwoInts(_:_:)` function has the same type as the `mathFunction` variable, and so this assignment is allowed by Swift's type-checker.

You can now call the assigned function with the name `mathFunction`:

<CodeSnippet>
  {`print("Result: \\(mathFunction(2, 3))")
// Prints "Result: 5"`}
</CodeSnippet>

A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:

<CodeSnippet>
  {`mathFunction = multiplyTwoInts\n
print("Result: \\(mathFunction(2, 3))")
// Prints "Result: 6"`}
</CodeSnippet>

As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:

<CodeSnippet>
  {`let anotherMathFunction = addTwoInts
// anotherMathFunction is inferred to be of type (Int, Int) -> Int`}
</CodeSnippet>

### Function Types as Parameter Types

You can use a function type such as `(Int, Int) -> Int` as a parameter type for another function. This enables you to leave some aspects of a function's implementation for the function's caller to provide when the function is called.

Here's an example to print the results of the math functions from above:

<CodeSnippet>
  {`func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \\(mathFunction(a, b))")
}\n
printMathResult(addTwoInts, 3, 5)
// Prints "Result: 8"`}
</CodeSnippet>

This example defines a function called `printMathResult(_:_:_:)`, which has three parameters. The first parameter is called mathFunction, and is of type (Int, Int) -> Int. You can pass any function of that type as the argument for this first parameter. The second and third parameters are called a and b, and are both of type Int. These are used as the two input values for the provided math function.

When `printMathResult(_:_:_:)` is called, it's passed the `addTwoInts(_:_:)` function, and the integer values `3` and `5`. It calls the provided function with the values `3` and `5`, and prints the result of `8`.

The role of `printMathResult(_:_:_:)` is to print the result of a call to a math function of an appropriate type. It doesn't matter what that function's implementation actually does—it matters only that the function is of the correct type. This enables `printMathResult(_:_:_:)` to hand off some of its functionality to the caller of the function in a type-safe way.

### Function Types as Return Types

You can use a function type as the return type of another function. You do this by writing a complete function type immediately after the return arrow (`->`) of the returning function.

The next example defines two simple functions called `stepForward(_:)` and `stepBackward(_:)`. The `stepForward(_:)` function returns a value one more than its input value, and the `stepBackward(_:)` function returns a value one less than its input value. Both functions have a type of `(Int) -> Int`:

<CodeSnippet>
  {`func stepForward(_ input: Int) -> Int {
    return input + 1
}\n
func stepBackward(_ input: Int) -> Int {
    return input - 1
}`}
</CodeSnippet>

Here's a function called `chooseStepFunction(backward:)`, whose return type is `(Int) -> Int`. The `chooseStepFunction(backward:)` function returns the `stepForward(_:)` function or the `stepBackward(_:)` function based on a Boolean parameter called `backward`:

<CodeSnippet>
  {`func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return backward ? stepBackward : stepForward
}`}
</CodeSnippet>

You can now use `chooseStepFunction(backward:)` to obtain a function that will step in one direction or the other:

<CodeSnippet>
  {`var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the stepBackward() function`}
</CodeSnippet>

The example above determines whether a positive or negative step is needed to move a variable called `currentValue` progressively closer to zero. `currentValue` has an initial value of `3`, which means that `currentValue > 0` returns `true`, causing `chooseStepFunction(backward:)` to return the `stepBackward(_:)` function. A reference to the returned function is stored in a constant called `moveNearerToZero`.

Now that `moveNearerToZero` refers to the correct function, it can be used to count to zero:

<CodeSnippet>
  {`print("Counting to zero:")
// Counting to zero:\n
while currentValue != 0 {
    print("\\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}\n
print("zero!")
// 3...
// 2...
// 1...
// zero!`}
</CodeSnippet>

## Nested Functions

All of the functions you have encountered so far in this chapter have been examples of _global functions_, which are defined at a global scope. You can also define functions inside the bodies of other functions, known as _nested functions_.

Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.

You can rewrite the `chooseStepFunction(backward:)` example above to use and return nested functions:

<CodeSnippet>
  {`func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }\n
    return backward ? stepBackward : stepForward
}\n
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the nested stepForward() function\n
while currentValue != 0 {
    print("\\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}\n
print("zero!")
// -4...
// -3...
// -2...
// -1...
// zero!`}
</CodeSnippet>
